diff --git a/client/registry.go b/client/registry.go
index d7e179a558..700cd2bd00 100644
--- a/client/registry.go
+++ b/client/registry.go
@@ -8,6 +8,7 @@ import (
 
 	"github.com/ory/fosite"
 	foauth2 "github.com/ory/fosite/handler/oauth2"
+	"github.com/ory/fosite/handler/rfc8628"
 	"github.com/ory/hydra/v2/jwk"
 	"github.com/ory/hydra/v2/x"
 )
@@ -23,5 +24,6 @@ type Registry interface {
 	ClientHasher() fosite.Hasher
 	OpenIDJWTStrategy() jwk.JWTSigner
 	OAuth2HMACStrategy() *foauth2.HMACSHAStrategy
+	RFC8628HMACStrategy() rfc8628.RFC8628CodeStrategy
 	config.Provider
 }
diff --git a/consent/handler.go b/consent/handler.go
index 81dd69b754..81e0c3f7a4 100644
--- a/consent/handler.go
+++ b/consent/handler.go
@@ -34,6 +34,7 @@ const (
 	LoginPath    = "/oauth2/auth/requests/login"
 	ConsentPath  = "/oauth2/auth/requests/consent"
 	LogoutPath   = "/oauth2/auth/requests/logout"
+	DevicePath   = "/oauth2/auth/requests/device"
 	SessionsPath = "/oauth2/auth/sessions"
 )
 
@@ -63,6 +64,8 @@ func (h *Handler) SetRoutes(admin *httprouterx.RouterAdmin) {
 	admin.GET(LogoutPath, h.getOAuth2LogoutRequest)
 	admin.PUT(LogoutPath+"/accept", h.acceptOAuth2LogoutRequest)
 	admin.PUT(LogoutPath+"/reject", h.rejectOAuth2LogoutRequest)
+
+	admin.PUT(DevicePath+"/verify", h.verifyUserCodeRequest)
 }
 
 // Revoke OAuth 2.0 Consent Session Parameters
@@ -936,3 +939,90 @@ func (h *Handler) getOAuth2LogoutRequest(w http.ResponseWriter, r *http.Request,
 
 	h.r.Writer().Write(w, r, request)
 }
+
+// Verify OAuth 2.0 User Code Request
+//
+// swagger:parameters verifyUserCodeRequest
+type verifyUserCodeRequest struct {
+	// in: query
+	// required: true
+	Challenge string `json:"device_challenge"`
+
+	// in: body
+	Body DeviceGrantVerifyUserCodeRequest
+}
+
+// swagger:route PUT /admin/oauth2/auth/requests/device/verify oAuth2 verifyUserCodeRequest
+//
+// # Verifies a device grant request
+//
+// Verifies a device grant request
+//
+//	Consumes:
+//	- application/json
+//
+//	Produces:
+//	- application/json
+//
+//	Schemes: http, https
+//
+//	Responses:
+//	  200: oAuth2RedirectTo
+//	  default: errorOAuth2
+func (h *Handler) verifyUserCodeRequest(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+	challenge := stringsx.Coalesce(
+		r.URL.Query().Get("device_challenge"),
+		r.URL.Query().Get("challenge"),
+	)
+	if challenge == "" {
+		h.r.Writer().WriteError(w, r, errorsx.WithStack(fosite.ErrInvalidRequest.WithHint(`Query parameter 'challenge' is not defined but should have been.`)))
+		return
+	}
+
+	var p DeviceGrantVerifyUserCodeRequest
+	d := json.NewDecoder(r.Body)
+	d.DisallowUnknownFields()
+	if err := d.Decode(&p); err != nil {
+		h.r.Writer().WriteError(w, r, errorsx.WithStack(fosite.ErrInvalidRequest.WithWrap(err).WithHintf("Unable to decode body because: %s", err)))
+		return
+	}
+
+	if p.UserCode == "" {
+		h.r.Writer().WriteError(w, r, errorsx.WithStack(fosite.ErrInvalidRequest.WithHint("Field 'user_code' must not be empty.")))
+		return
+	}
+
+	userCodeSignature, err := h.r.RFC8628HMACStrategy().UserCodeSignature(r.Context(), p.UserCode)
+	if err != nil {
+		h.r.Writer().WriteError(w, r, errorsx.WithStack(fosite.ErrServerError.WithWrap(err).WithHint(`'user_code' signature could not be computed`)))
+		return
+	}
+	userCodeRequest, err := h.r.OAuth2Storage().GetUserCodeSession(r.Context(), userCodeSignature, &fosite.DefaultSession{})
+	if err != nil {
+		h.r.Writer().WriteError(w, r, errorsx.WithStack(fosite.ErrNotFound.WithWrap(err).WithHint(`'user_code' session not found`)))
+		return
+	}
+
+	clientId := userCodeRequest.GetClient().GetID()
+	// UserCode & DeviceCode Request shares the same RequestId as it's the same request;
+	deviceRequestId := userCodeRequest.GetID()
+	requestedScopes := userCodeRequest.GetRequestedScopes()
+	requestedAudience := userCodeRequest.GetRequestedAudience()
+
+	err = h.r.OAuth2Storage().InvalidateUserCodeSession(r.Context(), userCodeSignature)
+	if err != nil {
+		h.r.Writer().WriteError(w, r, errorsx.WithStack(fosite.ErrServerError.WithWrap(err).WithHint(`Could not invalidate 'user_code'`)))
+		return
+	}
+
+	// req.GetID() is actually the DeviceCodeSignature
+	grantRequest, err := h.r.ConsentManager().AcceptDeviceGrantRequest(r.Context(), challenge, deviceRequestId, clientId, requestedScopes, requestedAudience)
+	if err != nil {
+		h.r.Writer().WriteError(w, r, errorsx.WithStack(fosite.ErrServerError.WithWrap(err).WithHint(`Could not accept device grant request`)))
+		return
+	}
+
+	h.r.Writer().Write(w, r, &OAuth2RedirectTo{
+		RedirectTo: urlx.SetQuery(h.c.OAuth2DeviceAuthorisationURL(r.Context()), url.Values{"device_verifier": {grantRequest.Verifier}, "client_id": {clientId}}).String(),
+	})
+}
diff --git a/consent/helper.go b/consent/helper.go
index ed15dd0314..d6cd0cf30a 100644
--- a/consent/helper.go
+++ b/consent/helper.go
@@ -21,7 +21,7 @@ import (
 	"github.com/ory/hydra/v2/client"
 )
 
-func sanitizeClientFromRequest(ar fosite.AuthorizeRequester) *client.Client {
+func sanitizeClientFromRequest(ar fosite.Requester) *client.Client {
 	return sanitizeClient(ar.GetClient().(*client.Client))
 }
 
diff --git a/consent/manager.go b/consent/manager.go
index 2910bcc9e4..3e06d4cfd5 100644
--- a/consent/manager.go
+++ b/consent/manager.go
@@ -9,6 +9,7 @@ import (
 
 	"github.com/gofrs/uuid"
 
+	"github.com/ory/fosite"
 	"github.com/ory/hydra/v2/client"
 )
 
@@ -59,4 +60,9 @@ type Manager interface {
 	AcceptLogoutRequest(ctx context.Context, challenge string) (*LogoutRequest, error)
 	RejectLogoutRequest(ctx context.Context, challenge string) error
 	VerifyAndInvalidateLogoutRequest(ctx context.Context, verifier string) (*LogoutRequest, error)
+
+	CreateDeviceGrantRequest(ctx context.Context, req *DeviceGrantRequest) error
+	GetDeviceGrantRequestByVerifier(ctx context.Context, verifier string) (*DeviceGrantRequest, error)
+	AcceptDeviceGrantRequest(ctx context.Context, challenge string, device_code_signature string, clientId string, requested_scopes fosite.Arguments, requested_aud fosite.Arguments) (*DeviceGrantRequest, error)
+	VerifyAndInvalidateDeviceGrantRequest(ctx context.Context, verifier string) (*DeviceGrantRequest, error)
 }
diff --git a/consent/strategy.go b/consent/strategy.go
index 9d31b3de4b..9a74154f7e 100644
--- a/consent/strategy.go
+++ b/consent/strategy.go
@@ -14,6 +14,7 @@ var _ Strategy = new(DefaultStrategy)
 
 type Strategy interface {
 	HandleOAuth2AuthorizationRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.AuthorizeRequester) (*AcceptOAuth2ConsentRequest, error)
+	HandleOAuth2DeviceAuthorizationRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.DeviceAuthorizeRequester) (*AcceptOAuth2ConsentRequest, error)
 	HandleOpenIDConnectLogout(ctx context.Context, w http.ResponseWriter, r *http.Request) (*LogoutResult, error)
 	HandleHeadlessLogout(ctx context.Context, w http.ResponseWriter, r *http.Request, sid string) error
 	ObfuscateSubjectIdentifier(ctx context.Context, cl fosite.Client, subject, forcedIdentifier string) (string, error)
diff --git a/consent/strategy_default.go b/consent/strategy_default.go
index 0de9ac2b16..90f0197fdc 100644
--- a/consent/strategy_default.go
+++ b/consent/strategy_default.go
@@ -114,21 +114,21 @@ func (s *DefaultStrategy) authenticationSession(ctx context.Context, w http.Resp
 	return session, nil
 }
 
-func (s *DefaultStrategy) requestAuthentication(ctx context.Context, w http.ResponseWriter, r *http.Request, ar fosite.AuthorizeRequester) error {
-	prompt := stringsx.Splitx(ar.GetRequestForm().Get("prompt"), " ")
+func (s *DefaultStrategy) requestAuthentication(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.Requester) error {
+	prompt := stringsx.Splitx(req.GetRequestForm().Get("prompt"), " ")
 	if stringslice.Has(prompt, "login") {
-		return s.forwardAuthenticationRequest(ctx, w, r, ar, "", time.Time{}, nil)
+		return s.forwardAuthenticationRequest(ctx, w, r, req, "", time.Time{}, nil)
 	}
 
 	session, err := s.authenticationSession(ctx, w, r)
 	if errors.Is(err, ErrNoAuthenticationSessionFound) {
-		return s.forwardAuthenticationRequest(ctx, w, r, ar, "", time.Time{}, nil)
+		return s.forwardAuthenticationRequest(ctx, w, r, req, "", time.Time{}, nil)
 	} else if err != nil {
 		return err
 	}
 
 	maxAge := int64(-1)
-	if ma := ar.GetRequestForm().Get("max_age"); len(ma) > 0 {
+	if ma := req.GetRequestForm().Get("max_age"); len(ma) > 0 {
 		var err error
 		maxAge, err = strconv.ParseInt(ma, 10, 64)
 		if err != nil {
@@ -140,12 +140,12 @@ func (s *DefaultStrategy) requestAuthentication(ctx context.Context, w http.Resp
 		if stringslice.Has(prompt, "none") {
 			return errorsx.WithStack(fosite.ErrLoginRequired.WithHint("Request failed because prompt is set to 'none' and authentication time reached 'max_age'."))
 		}
-		return s.forwardAuthenticationRequest(ctx, w, r, ar, "", time.Time{}, nil)
+		return s.forwardAuthenticationRequest(ctx, w, r, req, "", time.Time{}, nil)
 	}
 
-	idTokenHint := ar.GetRequestForm().Get("id_token_hint")
+	idTokenHint := req.GetRequestForm().Get("id_token_hint")
 	if idTokenHint == "" {
-		return s.forwardAuthenticationRequest(ctx, w, r, ar, session.Subject, time.Time(session.AuthenticatedAt), session)
+		return s.forwardAuthenticationRequest(ctx, w, r, req, session.Subject, time.Time(session.AuthenticatedAt), session)
 	}
 
 	hintSub, err := s.getSubjectFromIDTokenHint(r.Context(), idTokenHint)
@@ -153,11 +153,11 @@ func (s *DefaultStrategy) requestAuthentication(ctx context.Context, w http.Resp
 		return err
 	}
 
-	if err := s.matchesValueFromSession(r.Context(), ar.GetClient(), hintSub, session.Subject); errors.Is(err, ErrHintDoesNotMatchAuthentication) {
+	if err := s.matchesValueFromSession(r.Context(), req.GetClient(), hintSub, session.Subject); errors.Is(err, ErrHintDoesNotMatchAuthentication) {
 		return errorsx.WithStack(fosite.ErrLoginRequired.WithHint("Request failed because subject claim from id_token_hint does not match subject from authentication session."))
 	}
 
-	return s.forwardAuthenticationRequest(ctx, w, r, ar, session.Subject, time.Time(session.AuthenticatedAt), session)
+	return s.forwardAuthenticationRequest(ctx, w, r, req, session.Subject, time.Time(session.AuthenticatedAt), session)
 }
 
 func (s *DefaultStrategy) getIDTokenHintClaims(ctx context.Context, idTokenHint string) (jwt.MapClaims, error) {
@@ -184,7 +184,7 @@ func (s *DefaultStrategy) getSubjectFromIDTokenHint(ctx context.Context, idToken
 	return sub, nil
 }
 
-func (s *DefaultStrategy) forwardAuthenticationRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, ar fosite.AuthorizeRequester, subject string, authenticatedAt time.Time, session *LoginSession) error {
+func (s *DefaultStrategy) forwardAuthenticationRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.Requester, subject string, authenticatedAt time.Time, session *LoginSession) error {
 	if (subject != "" && authenticatedAt.IsZero()) || (subject == "" && !authenticatedAt.IsZero()) {
 		return errorsx.WithStack(fosite.ErrServerError.WithHint("Consent strategy returned a non-empty subject with an empty auth date, or an empty subject with a non-empty auth date."))
 	}
@@ -195,7 +195,7 @@ func (s *DefaultStrategy) forwardAuthenticationRequest(ctx context.Context, w ht
 	}
 
 	// Let'id validate that prompt is actually not "none" if we can't skip authentication
-	prompt := stringsx.Splitx(ar.GetRequestForm().Get("prompt"), " ")
+	prompt := stringsx.Splitx(req.GetRequestForm().Get("prompt"), " ")
 	if stringslice.Has(prompt, "none") && !skip {
 		return errorsx.WithStack(fosite.ErrLoginRequired.WithHint(`Prompt 'none' was requested, but no existing login session was found.`))
 	}
@@ -207,10 +207,13 @@ func (s *DefaultStrategy) forwardAuthenticationRequest(ctx context.Context, w ht
 
 	// Generate the request URL
 	iu := s.c.OAuth2AuthURL(ctx)
+	if _, ok := req.(fosite.DeviceAuthorizeRequester); ok {
+		iu = s.c.OAuth2DeviceAuthorisationURL(ctx)
+	}
 	iu.RawQuery = r.URL.RawQuery
 
 	var idTokenHintClaims jwt.MapClaims
-	if idTokenHint := ar.GetRequestForm().Get("id_token_hint"); len(idTokenHint) > 0 {
+	if idTokenHint := req.GetRequestForm().Get("id_token_hint"); len(idTokenHint) > 0 {
 		claims, err := s.getIDTokenHintClaims(r.Context(), idTokenHint)
 		if err != nil {
 			return err
@@ -230,7 +233,7 @@ func (s *DefaultStrategy) forwardAuthenticationRequest(ctx context.Context, w ht
 	}
 
 	// Set the session
-	cl := sanitizeClientFromRequest(ar)
+	cl := sanitizeClientFromRequest(req)
 	if err := s.r.ConsentManager().CreateLoginRequest(
 		r.Context(),
 		&LoginRequest{
@@ -238,8 +241,8 @@ func (s *DefaultStrategy) forwardAuthenticationRequest(ctx context.Context, w ht
 			Verifier:          verifier,
 			CSRF:              csrf,
 			Skip:              skip,
-			RequestedScope:    []string(ar.GetRequestedScopes()),
-			RequestedAudience: []string(ar.GetRequestedAudience()),
+			RequestedScope:    []string(req.GetRequestedScopes()),
+			RequestedAudience: []string(req.GetRequestedAudience()),
 			Subject:           subject,
 			Client:            cl,
 			RequestURL:        iu.String(),
@@ -248,10 +251,10 @@ func (s *DefaultStrategy) forwardAuthenticationRequest(ctx context.Context, w ht
 			SessionID:         sqlxx.NullString(sessionID),
 			OpenIDConnectContext: &OAuth2ConsentRequestOpenIDConnectContext{
 				IDTokenHintClaims: idTokenHintClaims,
-				ACRValues:         stringsx.Splitx(ar.GetRequestForm().Get("acr_values"), " "),
-				UILocales:         stringsx.Splitx(ar.GetRequestForm().Get("ui_locales"), " "),
-				Display:           ar.GetRequestForm().Get("display"),
-				LoginHint:         ar.GetRequestForm().Get("login_hint"),
+				ACRValues:         stringsx.Splitx(req.GetRequestForm().Get("acr_values"), " "),
+				UILocales:         stringsx.Splitx(req.GetRequestForm().Get("ui_locales"), " "),
+				Display:           req.GetRequestForm().Get("display"),
+				LoginHint:         req.GetRequestForm().Get("login_hint"),
 			},
 		},
 	); err != nil {
@@ -312,7 +315,7 @@ func (s *DefaultStrategy) revokeAuthenticationCookie(w http.ResponseWriter, r *h
 	return sid, nil
 }
 
-func (s *DefaultStrategy) verifyAuthentication(w http.ResponseWriter, r *http.Request, req fosite.AuthorizeRequester, verifier string) (*HandledLoginRequest, error) {
+func (s *DefaultStrategy) verifyAuthentication(w http.ResponseWriter, r *http.Request, req fosite.Requester, verifier string) (*HandledLoginRequest, error) {
 	ctx := r.Context()
 	session, err := s.r.ConsentManager().VerifyAndInvalidateLoginRequest(ctx, verifier)
 	if errors.Is(err, sqlcon.ErrNoRows) {
@@ -360,33 +363,64 @@ func (s *DefaultStrategy) verifyAuthentication(w http.ResponseWriter, r *http.Re
 
 	sessionID := session.LoginRequest.SessionID.String()
 
-	if err := s.r.OpenIDConnectRequestValidator().ValidatePrompt(ctx, &fosite.AuthorizeRequest{
-		ResponseTypes: req.GetResponseTypes(),
-		RedirectURI:   req.GetRedirectURI(),
-		State:         req.GetState(),
-		// HandledResponseTypes, this can be safely ignored because it's not being used by validation
-		Request: fosite.Request{
-			ID:                req.GetID(),
-			RequestedAt:       req.GetRequestedAt(),
-			Client:            req.GetClient(),
-			RequestedAudience: req.GetRequestedAudience(),
-			GrantedAudience:   req.GetGrantedAudience(),
-			RequestedScope:    req.GetRequestedScopes(),
-			GrantedScope:      req.GetGrantedScopes(),
-			Form:              req.GetRequestForm(),
-			Session: &openid.DefaultSession{
-				Claims: &jwt.IDTokenClaims{
-					Subject:     subjectIdentifier,
-					IssuedAt:    time.Now().UTC(),                // doesn't matter
-					ExpiresAt:   time.Now().Add(time.Hour).UTC(), // doesn't matter
-					AuthTime:    time.Time(session.AuthenticatedAt),
-					RequestedAt: session.RequestedAt,
+	var cleanReq fosite.Requester
+	if ar, ok := req.(fosite.AuthorizeRequester); ok {
+		cleanReq = &fosite.AuthorizeRequest{
+			ResponseTypes: ar.GetResponseTypes(),
+			RedirectURI:   ar.GetRedirectURI(),
+			State:         ar.GetState(),
+			// HandledResponseTypes, this can be safely ignored because it's not being used by validation
+			Request: fosite.Request{
+				ID:                req.GetID(),
+				RequestedAt:       req.GetRequestedAt(),
+				Client:            req.GetClient(),
+				RequestedAudience: req.GetRequestedAudience(),
+				GrantedAudience:   req.GetGrantedAudience(),
+				RequestedScope:    req.GetRequestedScopes(),
+				GrantedScope:      req.GetGrantedScopes(),
+				Form:              req.GetRequestForm(),
+				Session: &openid.DefaultSession{
+					Claims: &jwt.IDTokenClaims{
+						Subject:     subjectIdentifier,
+						IssuedAt:    time.Now().UTC(),                // doesn't matter
+						ExpiresAt:   time.Now().Add(time.Hour).UTC(), // doesn't matter
+						AuthTime:    time.Time(session.AuthenticatedAt),
+						RequestedAt: session.RequestedAt,
+					},
+					Headers: &jwt.Headers{},
+					Subject: session.Subject,
 				},
-				Headers: &jwt.Headers{},
-				Subject: session.Subject,
 			},
-		},
-	}); errors.Is(err, fosite.ErrLoginRequired) {
+		}
+	} else if _, ok := req.(fosite.DeviceAuthorizeRequester); ok {
+		cleanReq = &fosite.DeviceAuthorizeRequest{
+			Request: fosite.Request{
+				ID:                req.GetID(),
+				RequestedAt:       req.GetRequestedAt(),
+				Client:            req.GetClient(),
+				RequestedAudience: req.GetRequestedAudience(),
+				GrantedAudience:   req.GetGrantedAudience(),
+				RequestedScope:    req.GetRequestedScopes(),
+				GrantedScope:      req.GetGrantedScopes(),
+				Form:              req.GetRequestForm(),
+				Session: &openid.DefaultSession{
+					Claims: &jwt.IDTokenClaims{
+						Subject:     subjectIdentifier,
+						IssuedAt:    time.Now().UTC(),                // doesn't matter
+						ExpiresAt:   time.Now().Add(time.Hour).UTC(), // doesn't matter
+						AuthTime:    time.Time(session.AuthenticatedAt),
+						RequestedAt: session.RequestedAt,
+					},
+					Headers: &jwt.Headers{},
+					Subject: session.Subject,
+				},
+			},
+		}
+	} else {
+		return nil, errorsx.WithStack(fosite.ErrServerError.WithHint("Could not determine the Requester type"))
+	}
+
+	if err := s.r.OpenIDConnectRequestValidator().ValidatePrompt(ctx, cleanReq); errors.Is(err, fosite.ErrLoginRequired) {
 		// This indicates that something went wrong with checking the subject id - let's destroy the session to be safe
 		if err := s.revokeAuthenticationSession(ctx, w, r); err != nil {
 			return nil, err
@@ -456,10 +490,10 @@ func (s *DefaultStrategy) verifyAuthentication(w http.ResponseWriter, r *http.Re
 	return session, nil
 }
 
-func (s *DefaultStrategy) requestConsent(ctx context.Context, w http.ResponseWriter, r *http.Request, ar fosite.AuthorizeRequester, authenticationSession *HandledLoginRequest) error {
-	prompt := stringsx.Splitx(ar.GetRequestForm().Get("prompt"), " ")
+func (s *DefaultStrategy) requestConsent(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.Requester, authenticationSession *HandledLoginRequest) error {
+	prompt := stringsx.Splitx(req.GetRequestForm().Get("prompt"), " ")
 	if stringslice.Has(prompt, "consent") {
-		return s.forwardConsentRequest(ctx, w, r, ar, authenticationSession, nil)
+		return s.forwardConsentRequest(ctx, w, r, req, authenticationSession, nil)
 	}
 
 	// https://tools.ietf.org/html/rfc6749
@@ -476,14 +510,16 @@ func (s *DefaultStrategy) requestConsent(ctx context.Context, w http.ResponseWri
 	// authorization servers as identity proof.  Some operating systems may
 	// offer alternative platform-specific identity features that MAY be
 	// accepted, as appropriate.
-	if ar.GetClient().IsPublic() {
+	if req.GetClient().IsPublic() {
 		// The OpenID Connect Test Tool fails if this returns `consent_required` when `prompt=none` is used.
 		// According to the quote above, it should be ok to allow https to skip consent.
 		//
 		// This is tracked as issue: https://github.com/ory/hydra/issues/866
 		// This is also tracked as upstream issue: https://github.com/openid-certification/oidctest/issues/97
-		if !(ar.GetRedirectURI().Scheme == "https" || (fosite.IsLocalhost(ar.GetRedirectURI()) && ar.GetRedirectURI().Scheme == "http")) {
-			return s.forwardConsentRequest(ctx, w, r, ar, authenticationSession, nil)
+		if ar, ok := req.(fosite.AuthorizeRequester); ok {
+			if !(ar.GetRedirectURI().Scheme == "https" || (fosite.IsLocalhost(ar.GetRedirectURI()) && ar.GetRedirectURI().Scheme == "http")) {
+				return s.forwardConsentRequest(ctx, w, r, ar, authenticationSession, nil)
+			}
 		}
 	}
 
@@ -494,27 +530,27 @@ func (s *DefaultStrategy) requestConsent(ctx context.Context, w http.ResponseWri
 	// 	 return s.forwardConsentRequest(w, r, ar, authenticationSession, nil)
 	// }
 
-	consentSessions, err := s.r.ConsentManager().FindGrantedAndRememberedConsentRequests(r.Context(), ar.GetClient().GetID(), authenticationSession.Subject)
+	consentSessions, err := s.r.ConsentManager().FindGrantedAndRememberedConsentRequests(r.Context(), req.GetClient().GetID(), authenticationSession.Subject)
 	if errors.Is(err, ErrNoPreviousConsentFound) {
-		return s.forwardConsentRequest(ctx, w, r, ar, authenticationSession, nil)
+		return s.forwardConsentRequest(ctx, w, r, req, authenticationSession, nil)
 	} else if err != nil {
 		return err
 	}
 
-	if found := matchScopes(s.r.Config().GetScopeStrategy(ctx), consentSessions, ar.GetRequestedScopes()); found != nil {
-		return s.forwardConsentRequest(ctx, w, r, ar, authenticationSession, found)
+	if found := matchScopes(s.r.Config().GetScopeStrategy(ctx), consentSessions, req.GetRequestedScopes()); found != nil {
+		return s.forwardConsentRequest(ctx, w, r, req, authenticationSession, found)
 	}
 
-	return s.forwardConsentRequest(ctx, w, r, ar, authenticationSession, nil)
+	return s.forwardConsentRequest(ctx, w, r, req, authenticationSession, nil)
 }
 
-func (s *DefaultStrategy) forwardConsentRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, ar fosite.AuthorizeRequester, as *HandledLoginRequest, cs *AcceptOAuth2ConsentRequest) error {
+func (s *DefaultStrategy) forwardConsentRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.Requester, as *HandledLoginRequest, cs *AcceptOAuth2ConsentRequest) error {
 	skip := false
 	if cs != nil {
 		skip = true
 	}
 
-	prompt := stringsx.Splitx(ar.GetRequestForm().Get("prompt"), " ")
+	prompt := stringsx.Splitx(req.GetRequestForm().Get("prompt"), " ")
 	if stringslice.Has(prompt, "none") && !skip {
 		return errorsx.WithStack(fosite.ErrConsentRequired.WithHint(`Prompt 'none' was requested, but no previous consent was found.`))
 	}
@@ -524,7 +560,7 @@ func (s *DefaultStrategy) forwardConsentRequest(ctx context.Context, w http.Resp
 	challenge := strings.Replace(uuid.New(), "-", "", -1)
 	csrf := strings.Replace(uuid.New(), "-", "", -1)
 
-	cl := sanitizeClientFromRequest(ar)
+	cl := sanitizeClientFromRequest(req)
 	if err := s.r.ConsentManager().CreateConsentRequest(
 		r.Context(),
 		&OAuth2ConsentRequest{
@@ -534,8 +570,8 @@ func (s *DefaultStrategy) forwardConsentRequest(ctx context.Context, w http.Resp
 			Verifier:               verifier,
 			CSRF:                   csrf,
 			Skip:                   skip,
-			RequestedScope:         []string(ar.GetRequestedScopes()),
-			RequestedAudience:      []string(ar.GetRequestedAudience()),
+			RequestedScope:         []string(req.GetRequestedScopes()),
+			RequestedAudience:      []string(req.GetRequestedAudience()),
 			Subject:                as.Subject,
 			Client:                 cl,
 			RequestURL:             as.LoginRequest.RequestURL,
@@ -571,7 +607,7 @@ func (s *DefaultStrategy) forwardConsentRequest(ctx context.Context, w http.Resp
 	return errorsx.WithStack(ErrAbortOAuth2Request)
 }
 
-func (s *DefaultStrategy) verifyConsent(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.AuthorizeRequester, verifier string) (*AcceptOAuth2ConsentRequest, error) {
+func (s *DefaultStrategy) verifyConsent(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.Requester, verifier string) (*AcceptOAuth2ConsentRequest, error) {
 	session, err := s.r.ConsentManager().VerifyAndInvalidateConsentRequest(r.Context(), verifier)
 	if errors.Is(err, sqlcon.ErrNoRows) {
 		return nil, errorsx.WithStack(fosite.ErrAccessDenied.WithHint("The consent verifier has already been used, has not been granted, or is invalid."))
@@ -1016,6 +1052,91 @@ func (s *DefaultStrategy) HandleHeadlessLogout(ctx context.Context, w http.Respo
 	return nil
 }
 
+func (s *DefaultStrategy) requestDevice(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.Requester) error {
+	return s.forwardDeviceRequest(ctx, w, r, req)
+}
+
+func (s *DefaultStrategy) forwardDeviceRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.Requester) error {
+	// Set up csrf/challenge/verifier values
+	verifier := strings.Replace(uuid.New(), "-", "", -1)
+	challenge := strings.Replace(uuid.New(), "-", "", -1)
+	csrf := strings.Replace(uuid.New(), "-", "", -1)
+
+	// Generate the request URL
+	iu := s.c.OAuth2DeviceAuthorisationURL(ctx)
+	iu.RawQuery = r.URL.RawQuery
+
+	if err := s.r.ConsentManager().CreateDeviceGrantRequest(
+		r.Context(),
+		&DeviceGrantRequest{
+			ID:         challenge,
+			Verifier:   verifier,
+			CSRF:       csrf,
+			RequestURL: iu.String(),
+		},
+	); err != nil {
+		return errorsx.WithStack(err)
+	}
+
+	store, err := s.r.CookieStore(ctx)
+	if err != nil {
+		return err
+	}
+
+	if err := createCsrfSession(w, r, s.r.Config(), store, s.r.Config().CookieNameDeviceVerifyCSRF(ctx), csrf, s.c.ConsentRequestMaxAge(ctx)); err != nil {
+		return errorsx.WithStack(err)
+	}
+
+	query := url.Values{"device_challenge": {challenge}}
+	if r.URL.Query().Has("user_code") {
+		query.Add("user_code", r.URL.Query().Get("user_code"))
+	}
+
+	http.Redirect(w, r, urlx.SetQuery(s.c.DeviceUrl(ctx), query).String(), http.StatusFound)
+
+	// generate the verifier
+	return errorsx.WithStack(ErrAbortOAuth2Request)
+}
+
+func (s *DefaultStrategy) verifyDevice(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.DeviceAuthorizeRequester, verifier string) (*DeviceGrantRequest, error) {
+	session, err := s.r.ConsentManager().GetDeviceGrantRequestByVerifier(ctx, verifier)
+	if errors.Is(err, sqlcon.ErrNoRows) {
+		return nil, errorsx.WithStack(fosite.ErrAccessDenied.WithHint("The device verifier has already been used, has not been granted, or is invalid."))
+	} else if err != nil {
+		return nil, err
+	}
+
+	if session.Client.GetID() != req.GetClient().GetID() {
+		return nil, errorsx.WithStack(fosite.ErrInvalidGrant.WithHint("The OAuth 2.0 Client ID from this request does not match the one from the authorize request."))
+	}
+
+	if time.Time(session.AcceptedAt).Add(s.c.ConsentRequestMaxAge(ctx)).Before(time.Now()) {
+		return nil, errorsx.WithStack(fosite.ErrRequestUnauthorized.WithHint("The device request has expired. Please try again."))
+	}
+
+	store, err := s.r.CookieStore(ctx)
+	if err != nil {
+		return nil, err
+	}
+
+	if err = validateCsrfSession(r, s.r.Config(), store, s.r.Config().CookieNameDeviceVerifyCSRF(ctx), session.CSRF); err != nil {
+		return nil, err
+	}
+
+	return session, nil
+}
+
+func (s *DefaultStrategy) invalidateDeviceRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.DeviceAuthorizeRequester, verifier string) (*DeviceGrantRequest, error) {
+	session, err := s.r.ConsentManager().VerifyAndInvalidateDeviceGrantRequest(ctx, verifier)
+	if errors.Is(err, sqlcon.ErrNoRows) {
+		return nil, errorsx.WithStack(fosite.ErrAccessDenied.WithHint("The device verifier has already been used, has not been granted, or is invalid."))
+	} else if err != nil {
+		return nil, err
+	}
+
+	return session, nil
+}
+
 func (s *DefaultStrategy) HandleOAuth2AuthorizationRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.AuthorizeRequester) (*AcceptOAuth2ConsentRequest, error) {
 	authenticationVerifier := strings.TrimSpace(req.GetRequestForm().Get("login_verifier"))
 	consentVerifier := strings.TrimSpace(req.GetRequestForm().Get("consent_verifier"))
@@ -1057,3 +1178,46 @@ func (s *DefaultStrategy) ObfuscateSubjectIdentifier(ctx context.Context, cl fos
 	}
 	return subject, nil
 }
+
+func (s *DefaultStrategy) HandleOAuth2DeviceAuthorizationRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.DeviceAuthorizeRequester) (*AcceptOAuth2ConsentRequest, error) {
+	authenticationVerifier := strings.TrimSpace(req.GetRequestForm().Get("login_verifier"))
+	consentVerifier := strings.TrimSpace(req.GetRequestForm().Get("consent_verifier"))
+	deviceVerifier := strings.TrimSpace(req.GetRequestForm().Get("device_verifier"))
+
+	if deviceVerifier == "" && authenticationVerifier == "" && consentVerifier == "" {
+		// ok, we need to process this request and redirect to device auth endpoint
+		return nil, s.requestDevice(ctx, w, r, req)
+	} else if authenticationVerifier == "" && consentVerifier == "" {
+		deviceSession, err := s.verifyDevice(ctx, w, r, req, deviceVerifier)
+		if err != nil {
+			return nil, err
+		}
+
+		// Set scope & audience requested by remote device;
+		req.SetRequestedScopes(fosite.Arguments(deviceSession.RequestedScope))
+		req.SetRequestedAudience(fosite.Arguments(deviceSession.RequestedAudience))
+
+		return nil, s.requestAuthentication(ctx, w, r, req)
+	} else if consentVerifier == "" {
+		authSession, err := s.verifyAuthentication(w, r, req, authenticationVerifier)
+		if err != nil {
+			return nil, err
+		}
+
+		// ok, we need to process this request and redirect to auth endpoint
+		return nil, s.requestConsent(ctx, w, r, req, authSession)
+	}
+
+	deviceSession, err := s.invalidateDeviceRequest(ctx, w, r, req, deviceVerifier)
+	if err != nil {
+		return nil, err
+	}
+	req.SetDeviceCodeSignature(deviceSession.DeviceCodeSignature.String())
+
+	consentSession, err := s.verifyConsent(ctx, w, r, req, consentVerifier)
+	if err != nil {
+		return nil, err
+	}
+
+	return consentSession, nil
+}
diff --git a/consent/types.go b/consent/types.go
index 6a389e9d8b..62f42317f8 100644
--- a/consent/types.go
+++ b/consent/types.go
@@ -14,9 +14,9 @@ import (
 	"github.com/gobuffalo/pop/v6"
 	"github.com/gofrs/uuid"
 
+	"github.com/ory/fosite"
 	"github.com/ory/x/errorsx"
 
-	"github.com/ory/fosite"
 	"github.com/ory/hydra/v2/client"
 	"github.com/ory/x/sqlcon"
 	"github.com/ory/x/sqlxx"
@@ -450,6 +450,83 @@ type LogoutResult struct {
 	FrontChannelLogoutURLs []string
 }
 
+// Contains information on an ongoing device grant request.
+//
+// swagger:model deviceGrantRequest
+type DeviceGrantRequest struct {
+	// ID is the identifier ("device challenge") of the device grant request. It is used to
+	// identify the session.
+	//
+	// required: true
+	ID  string    `json:"challenge" db:"challenge"`
+	NID uuid.UUID `json:"-" db:"nid"`
+
+	// RequestedScope contains the OAuth 2.0 Scope requested by the OAuth 2.0 Client.
+	//
+	// required: true
+	RequestedScope sqlxx.StringSlicePipeDelimiter `json:"requested_scope" db:"requested_scope"`
+
+	// RequestedScope contains the access token audience as requested by the OAuth 2.0 Client.
+	//
+	// required: true
+	RequestedAudience sqlxx.StringSlicePipeDelimiter `json:"requested_access_token_audience" db:"requested_audience"`
+
+	// RequestURL is the original Device Grant URL requested.
+	RequestURL string `json:"request_url" db:"request_url"`
+
+	// Client is the OAuth 2.0 Client that initiated the request.
+	//
+	// required: true
+	Client   *client.Client   `json:"client" db:"-"`
+	ClientID sqlxx.NullString `json:"-" db:"client_id"`
+
+	// DeviceCodeSignature is the OAuth 2.0 Device Authorization Grant Device Code Signature
+	//
+	// required: true
+	DeviceCodeSignature sqlxx.NullString `json:"-" db:"device_code_signature"`
+
+	CSRF     string `json:"-" db:"csrf"`
+	Verifier string `json:"-" db:"verifier"`
+
+	Accepted   bool           `json:"-" db:"accepted"`
+	AcceptedAt sqlxx.NullTime `json:"handled_at" db:"accepted_at"`
+}
+
+func (_ DeviceGrantRequest) TableName() string {
+	return "hydra_oauth2_device_grant_request"
+}
+
+func (r *DeviceGrantRequest) BeforeSave(_ *pop.Connection) error {
+	if r.Client != nil {
+		r.ClientID = sqlxx.NullString(r.Client.GetID())
+	}
+	return nil
+}
+
+func (r *DeviceGrantRequest) AfterFind(c *pop.Connection) error {
+	if r.ClientID != "" {
+		r.Client = &client.Client{}
+		return sqlcon.HandleError(c.Where("id = ?", r.ClientID).First(r.Client))
+	}
+
+	return nil
+}
+
+// Contains information on an device verification
+//
+// swagger:model verifyUserCodeRequest
+type DeviceGrantVerifyUserCodeRequest struct {
+	UserCode string `json:"user_code"`
+}
+
+// Returned when the device grant request was used.
+//
+// swagger:ignore
+type DeviceGrantResponse struct {
+	RedirectTo   string `json:"redirect_to"`
+	ErrorMessage string `json:"error_message"`
+}
+
 // Contains information on an ongoing login request.
 //
 // swagger:model oAuth2LoginRequest
diff --git a/driver/config/provider.go b/driver/config/provider.go
index 74d4179d7c..9295c0a187 100644
--- a/driver/config/provider.go
+++ b/driver/config/provider.go
@@ -46,6 +46,7 @@ const (
 	KeyOIDCDiscoverySupportedClaims              = "webfinger.oidc_discovery.supported_claims"
 	KeyOIDCDiscoverySupportedScope               = "webfinger.oidc_discovery.supported_scope"
 	KeyOIDCDiscoveryUserinfoEndpoint             = "webfinger.oidc_discovery.userinfo_url"
+	KeyOAuth2DeviceAuthorisationURL              = "webfinger.oidc_discovery.device_authorization_url"
 	KeySubjectTypesSupported                     = "oidc.subject_identifiers.supported_types"
 	KeyDefaultClientScope                        = "oidc.dynamic_client_registration.default_scope"
 	KeyDSN                                       = "dsn"
@@ -60,6 +61,7 @@ const (
 	KeyCookieSecure                              = "serve.cookies.secure"
 	KeyCookieLoginCSRFName                       = "serve.cookies.names.login_csrf"
 	KeyCookieConsentCSRFName                     = "serve.cookies.names.consent_csrf"
+	KeyCookieDeviceVerifyCSRFName                = "serve.cookies.names.consent_device_verify"
 	KeyCookieSessionName                         = "serve.cookies.names.session"
 	KeyCookieSessionPath                         = "serve.cookies.paths.session"
 	KeyConsentRequestMaxAge                      = "ttl.login_consent_request"
@@ -67,6 +69,7 @@ const (
 	KeyRefreshTokenLifespan                      = "ttl.refresh_token" // #nosec G101
 	KeyIDTokenLifespan                           = "ttl.id_token"      // #nosec G101
 	KeyAuthCodeLifespan                          = "ttl.auth_code"
+	KeyDeviceAndUserCodeLifespan                 = "ttl.device_user_code" // #nosec G101
 	KeyScopeStrategy                             = "strategies.scope"
 	KeyGetCookieSecrets                          = "secrets.cookie"
 	KeyGetSystemSecret                           = "secrets.system"
@@ -75,13 +78,17 @@ const (
 	KeyLogoutURL                                 = "urls.logout"
 	KeyConsentURL                                = "urls.consent"
 	KeyErrorURL                                  = "urls.error"
+	KeyDeviceURL                                 = "urls.device"
+	KeyDeviceDoneURL                             = "urls.post_device_done"
 	KeyPublicURL                                 = "urls.self.public"
 	KeyAdminURL                                  = "urls.self.admin"
 	KeyIssuerURL                                 = "urls.self.issuer"
+	KeyDeviceVerificationURL                     = "urls.self.device"
 	KeyAccessTokenStrategy                       = "strategies.access_token"
 	KeyDBIgnoreUnknownTableColumns               = "db.ignore_unknown_table_columns"
 	KeySubjectIdentifierAlgorithmSalt            = "oidc.subject_identifiers.pairwise.salt"
 	KeyPublicAllowDynamicRegistration            = "oidc.dynamic_client_registration.enabled"
+	KeyDeviceAuthTokenPollingInterval            = "oauth2.device_authorization.token_polling_interval" // #nosec G101
 	KeyPKCEEnforced                              = "oauth2.pkce.enforced"
 	KeyPKCEEnforcedForPublicClients              = "oauth2.pkce.enforced_for_public_clients"
 	KeyLogLevel                                  = "log.level"
@@ -351,6 +358,14 @@ func (p *DefaultProvider) fallbackURL(ctx context.Context, path string, host str
 	return &u
 }
 
+func (p *DefaultProvider) GetDeviceAndUserCodeLifespan(ctx context.Context) time.Duration {
+	return p.p.DurationF(KeyDeviceAndUserCodeLifespan, time.Minute*15)
+}
+
+func (p *DefaultProvider) GetDeviceAuthTokenPollingInterval(ctx context.Context) time.Duration {
+	return p.p.DurationF(KeyDeviceAuthTokenPollingInterval, time.Second*5)
+}
+
 func (p *DefaultProvider) LoginURL(ctx context.Context) *url.URL {
 	return urlRoot(p.getProvider(ctx).URIF(KeyLoginURL, p.publicFallbackURL(ctx, "oauth2/fallbacks/login")))
 }
@@ -367,6 +382,14 @@ func (p *DefaultProvider) ErrorURL(ctx context.Context) *url.URL {
 	return urlRoot(p.getProvider(ctx).RequestURIF(KeyErrorURL, p.publicFallbackURL(ctx, "oauth2/fallbacks/error")))
 }
 
+func (p *DefaultProvider) DeviceUrl(ctx context.Context) *url.URL {
+	return urlRoot(p.getProvider(ctx).URIF(KeyDeviceURL, p.publicFallbackURL(ctx, "oauth2/fallbacks/device")))
+}
+
+func (p *DefaultProvider) DeviceDoneURL(ctx context.Context) *url.URL {
+	return urlRoot(p.getProvider(ctx).RequestURIF(KeyDeviceDoneURL, p.publicFallbackURL(ctx, "oauth2/fallbacks/device/done")))
+}
+
 func (p *DefaultProvider) PublicURL(ctx context.Context) *url.URL {
 	return urlRoot(p.getProvider(ctx).RequestURIF(KeyPublicURL, p.IssuerURL(ctx)))
 }
@@ -397,6 +420,10 @@ func (p *DefaultProvider) OAuth2AuthURL(ctx context.Context) *url.URL {
 	return p.getProvider(ctx).RequestURIF(KeyOAuth2AuthURL, urlx.AppendPaths(p.PublicURL(ctx), "/oauth2/auth"))
 }
 
+func (p *DefaultProvider) OAuth2DeviceAuthorisationURL(ctx context.Context) *url.URL {
+	return p.getProvider(ctx).RequestURIF(KeyOAuth2DeviceAuthorisationURL, urlx.AppendPaths(p.PublicURL(ctx), "/oauth2/device/auth"))
+}
+
 func (p *DefaultProvider) JWKSURL(ctx context.Context) *url.URL {
 	return p.getProvider(ctx).RequestURIF(KeyJWKSURL, urlx.AppendPaths(p.IssuerURL(ctx), "/.well-known/jwks.json"))
 }
@@ -536,6 +563,10 @@ func (p *DefaultProvider) CookieNameConsentCSRF(ctx context.Context) string {
 	return p.cookieSuffix(ctx, KeyCookieConsentCSRFName)
 }
 
+func (p *DefaultProvider) CookieNameDeviceVerifyCSRF(ctx context.Context) string {
+	return p.cookieSuffix(ctx, KeyCookieDeviceVerifyCSRFName)
+}
+
 func (p *DefaultProvider) SessionCookieName(ctx context.Context) string {
 	return p.cookieSuffix(ctx, KeyCookieSessionName)
 }
diff --git a/driver/config/provider_test.go b/driver/config/provider_test.go
index f7f3b4aef8..a51f832a45 100644
--- a/driver/config/provider_test.go
+++ b/driver/config/provider_test.go
@@ -278,6 +278,7 @@ func TestViperProviderValidates(t *testing.T) {
 	// webfinger
 	assert.Equal(t, []string{"hydra.openid.id-token", "hydra.jwt.access-token"}, c.WellKnownKeys(ctx))
 	assert.Equal(t, urlx.ParseOrPanic("https://example.com"), c.OAuth2ClientRegistrationURL(ctx))
+	assert.Equal(t, urlx.ParseOrPanic("https://example.com/device_authorization"), c.OAuth2DeviceAuthorisationURL(ctx))
 	assert.Equal(t, urlx.ParseOrPanic("https://example.com/jwks.json"), c.JWKSURL(ctx))
 	assert.Equal(t, urlx.ParseOrPanic("https://example.com/auth"), c.OAuth2AuthURL(ctx))
 	assert.Equal(t, urlx.ParseOrPanic("https://example.com/token"), c.OAuth2TokenURL(ctx))
@@ -296,9 +297,11 @@ func TestViperProviderValidates(t *testing.T) {
 	assert.Equal(t, urlx.ParseOrPanic("https://admin/"), c.AdminURL(ctx))
 	assert.Equal(t, urlx.ParseOrPanic("https://login/"), c.LoginURL(ctx))
 	assert.Equal(t, urlx.ParseOrPanic("https://consent/"), c.ConsentURL(ctx))
+	assert.Equal(t, urlx.ParseOrPanic("https://device/"), c.DeviceUrl(ctx))
 	assert.Equal(t, urlx.ParseOrPanic("https://logout/"), c.LogoutURL(ctx))
 	assert.Equal(t, urlx.ParseOrPanic("https://error/"), c.ErrorURL(ctx))
 	assert.Equal(t, urlx.ParseOrPanic("https://post_logout/"), c.LogoutRedirectURL(ctx))
+	assert.Equal(t, urlx.ParseOrPanic("https://post_device/"), c.DeviceDoneURL(ctx))
 
 	// strategies
 	assert.True(t, c.GetScopeStrategy(ctx)([]string{"openid"}, "openid"), "should us fosite.ExactScopeStrategy")
@@ -312,12 +315,14 @@ func TestViperProviderValidates(t *testing.T) {
 	assert.Equal(t, 2*time.Hour, c.GetRefreshTokenLifespan(ctx))
 	assert.Equal(t, 2*time.Hour, c.GetIDTokenLifespan(ctx))
 	assert.Equal(t, 2*time.Hour, c.GetAuthorizeCodeLifespan(ctx))
+	assert.Equal(t, 2*time.Hour, c.GetDeviceAndUserCodeLifespan(ctx))
 
 	// oauth2
 	assert.Equal(t, true, c.GetSendDebugMessagesToClients(ctx))
 	assert.Equal(t, 20, c.GetBCryptCost(ctx))
 	assert.Equal(t, true, c.GetEnforcePKCE(ctx))
 	assert.Equal(t, true, c.GetEnforcePKCEForPublicClients(ctx))
+	assert.Equal(t, 2*time.Hour, c.GetDeviceAuthTokenPollingInterval(ctx))
 
 	// secrets
 	secret, err := c.GetGlobalSecret(ctx)
@@ -386,16 +391,20 @@ func TestLoginConsentURL(t *testing.T) {
 	p := MustNew(context.Background(), l)
 	p.MustSet(ctx, KeyLoginURL, "http://localhost:8080/oauth/login")
 	p.MustSet(ctx, KeyConsentURL, "http://localhost:8080/oauth/consent")
+	p.MustSet(ctx, KeyDeviceURL, "http://localhost:8080/oauth/device")
 
 	assert.Equal(t, "http://localhost:8080/oauth/login", p.LoginURL(ctx).String())
 	assert.Equal(t, "http://localhost:8080/oauth/consent", p.ConsentURL(ctx).String())
+	assert.Equal(t, "http://localhost:8080/oauth/device", p.DeviceUrl(ctx).String())
 
 	p2 := MustNew(context.Background(), l)
 	p2.MustSet(ctx, KeyLoginURL, "http://localhost:3000/#/oauth/login")
 	p2.MustSet(ctx, KeyConsentURL, "http://localhost:3000/#/oauth/consent")
+	p2.MustSet(ctx, KeyDeviceURL, "http://localhost:3000/#/oauth/device")
 
 	assert.Equal(t, "http://localhost:3000/#/oauth/login", p2.LoginURL(ctx).String())
 	assert.Equal(t, "http://localhost:3000/#/oauth/consent", p2.ConsentURL(ctx).String())
+	assert.Equal(t, "http://localhost:3000/#/oauth/device", p2.DeviceUrl(ctx).String())
 }
 
 func TestInfinitRefreshTokenTTL(t *testing.T) {
diff --git a/driver/registry_base.go b/driver/registry_base.go
index d2d458427a..df008973c3 100644
--- a/driver/registry_base.go
+++ b/driver/registry_base.go
@@ -20,6 +20,7 @@ import (
 	"github.com/ory/fosite/compose"
 	foauth2 "github.com/ory/fosite/handler/oauth2"
 	"github.com/ory/fosite/handler/openid"
+	"github.com/ory/fosite/handler/rfc8628"
 	"github.com/ory/herodot"
 	"github.com/ory/hydra/v2/client"
 	"github.com/ory/hydra/v2/consent"
@@ -82,6 +83,7 @@ type RegistryBase struct {
 	oidcs           jwk.JWTSigner
 	ats             jwk.JWTSigner
 	hmacs           *foauth2.HMACSHAStrategy
+	devHmac         rfc8628.RFC8628CodeStrategy
 	fc              *fositex.Config
 	publicCORS      *cors.Cors
 }
@@ -376,6 +378,15 @@ func (m *RegistryBase) OAuth2HMACStrategy() *foauth2.HMACSHAStrategy {
 	return m.hmacs
 }
 
+func (m *RegistryBase) RFC8628HMACStrategy() rfc8628.RFC8628CodeStrategy {
+	if m.devHmac != nil {
+		return m.devHmac
+	}
+
+	m.devHmac = compose.NewDeviceStrategy(m.OAuth2Config())
+	return m.devHmac
+}
+
 func (m *RegistryBase) OAuth2Config() *fositex.Config {
 	if m.fc != nil {
 		return m.fc
@@ -392,6 +403,7 @@ func (m *RegistryBase) OAuth2ProviderConfig() fosite.Configurator {
 
 	conf := m.OAuth2Config()
 	hmacAtStrategy := m.OAuth2HMACStrategy()
+	devHmacAtStrategy := m.RFC8628HMACStrategy()
 	oidcSigner := m.OpenIDJWTStrategy()
 	atSigner := m.AccessTokenJWTStrategy()
 	jwtAtStrategy := &foauth2.DefaultJWTStrategy{
@@ -406,6 +418,7 @@ func (m *RegistryBase) OAuth2ProviderConfig() fosite.Configurator {
 			HMACSHAStrategy: hmacAtStrategy,
 			Config:          conf,
 		}),
+		RFC8628CodeStrategy: devHmacAtStrategy,
 		OpenIDConnectTokenStrategy: &openid.DefaultStrategy{
 			Config: conf,
 			Signer: oidcSigner,
diff --git a/fositex/config.go b/fositex/config.go
index 9336305396..d4ad0c78c4 100644
--- a/fositex/config.go
+++ b/fositex/config.go
@@ -36,17 +36,22 @@ type factory func(config fosite.Configurator, storage interface{}, strategy inte
 type Config struct {
 	deps configDependencies
 
-	authorizeEndpointHandlers  fosite.AuthorizeEndpointHandlers
-	tokenEndpointHandlers      fosite.TokenEndpointHandlers
-	tokenIntrospectionHandlers fosite.TokenIntrospectionHandlers
-	revocationHandlers         fosite.RevocationHandlers
+	authorizeEndpointHandlers       fosite.AuthorizeEndpointHandlers
+	tokenEndpointHandlers           fosite.TokenEndpointHandlers
+	tokenIntrospectionHandlers      fosite.TokenIntrospectionHandlers
+	revocationHandlers              fosite.RevocationHandlers
+	deviceEndpointHandlers          fosite.DeviceEndpointHandlers
+	deviceAuthorizeEndpointHandlers fosite.DeviceAuthorizeEndpointHandlers
 
 	*config.DefaultProvider
 }
 
 var defaultResponseModeHandler = fosite.NewDefaultResponseModeHandler()
 var defaultFactories = []factory{
-	compose.OAuth2AuthorizeExplicitFactory,
+	compose.RFC8628DeviceFactory,
+	compose.RFC8628DeviceAuthorizationTokenFactory,
+	compose.OAuth2AuthorizeExplicitAuthFactory,
+	compose.OAuth2AuthorizeExplicitTokenFactory,
 	compose.OAuth2AuthorizeImplicitFactory,
 	compose.OAuth2ClientCredentialsGrantFactory,
 	compose.OAuth2RefreshTokenGrantFactory,
@@ -54,6 +59,7 @@ var defaultFactories = []factory{
 	compose.OpenIDConnectHybridFactory,
 	compose.OpenIDConnectImplicitFactory,
 	compose.OpenIDConnectRefreshFactory,
+	compose.OpenIDConnectDeviceFactory,
 	compose.OAuth2TokenRevocationFactory,
 	compose.OAuth2TokenIntrospectionFactory,
 	compose.OAuth2PKCEFactory,
@@ -71,6 +77,12 @@ func NewConfig(deps configDependencies) *Config {
 func (c *Config) LoadDefaultHanlders(strategy interface{}) {
 	for _, factory := range defaultFactories {
 		res := factory(c, c.deps.Persister(), strategy)
+		if dh, ok := res.(fosite.DeviceEndpointHandler); ok {
+			c.deviceEndpointHandlers.Append(dh)
+		}
+		if dah, ok := res.(fosite.DeviceAuthorizeEndpointHandler); ok {
+			c.deviceAuthorizeEndpointHandlers.Append(dah)
+		}
 		if ah, ok := res.(fosite.AuthorizeEndpointHandler); ok {
 			c.authorizeEndpointHandlers.Append(ah)
 		}
@@ -110,6 +122,14 @@ func (c *Config) GetRevocationHandlers(ctx context.Context) fosite.RevocationHan
 	return c.revocationHandlers
 }
 
+func (c *Config) GetDeviceEndpointHandlers(ctx context.Context) fosite.DeviceEndpointHandlers {
+	return c.deviceEndpointHandlers
+}
+
+func (c *Config) GetDeviceAuthorizeEndpointHandlers(ctx context.Context) fosite.DeviceAuthorizeEndpointHandlers {
+	return c.deviceAuthorizeEndpointHandlers
+}
+
 func (c *Config) GetGrantTypeJWTBearerCanSkipClientAuth(ctx context.Context) bool {
 	return false
 }
@@ -199,3 +219,11 @@ func (c *Config) GetFormPostHTMLTemplate(ctx context.Context) *template.Template
 func (c *Config) GetTokenURL(ctx context.Context) string {
 	return urlx.AppendPaths(c.deps.Config().PublicURL(ctx), oauth2.TokenPath).String()
 }
+
+func (c *Config) GetDeviceDone(ctx context.Context) string {
+	return c.deps.Config().DeviceDoneURL(ctx).String()
+}
+
+func (c *Config) GetDeviceVerificationURL(ctx context.Context) string {
+	return urlx.AppendPaths(c.deps.Config().PublicURL(ctx), oauth2.DeviceAuthPath).String()
+}
diff --git a/fositex/token_strategy.go b/fositex/token_strategy.go
index 2a84822a24..45fcb41bfd 100644
--- a/fositex/token_strategy.go
+++ b/fositex/token_strategy.go
@@ -9,6 +9,7 @@ import (
 
 	"github.com/ory/fosite"
 	foauth2 "github.com/ory/fosite/handler/oauth2"
+	fdevice "github.com/ory/fosite/handler/rfc8628"
 	"github.com/ory/hydra/v2/client"
 	"github.com/ory/hydra/v2/driver/config"
 )
@@ -17,9 +18,10 @@ var _ foauth2.CoreStrategy = (*TokenStrategy)(nil)
 
 // TokenStrategy uses the correct token strategy (jwt, opaque) depending on the configuration.
 type TokenStrategy struct {
-	c    *config.DefaultProvider
-	hmac *foauth2.HMACSHAStrategy
-	jwt  *foauth2.DefaultJWTStrategy
+	c       *config.DefaultProvider
+	hmac    *foauth2.HMACSHAStrategy
+	devHmac *fdevice.DefaultDeviceStrategy
+	jwt     *foauth2.DefaultJWTStrategy
 }
 
 // NewTokenStrategy returns a new TokenStrategy.
@@ -86,3 +88,27 @@ func genericSignature(token string) string {
 		return ""
 	}
 }
+
+func (t TokenStrategy) DeviceCodeSignature(ctx context.Context, token string) (signature string, err error) {
+	return t.devHmac.DeviceCodeSignature(ctx, token)
+}
+
+func (t *TokenStrategy) GenerateDeviceCode(ctx context.Context) (token string, signature string, err error) {
+	return t.devHmac.GenerateDeviceCode(ctx)
+}
+
+func (t *TokenStrategy) ValidateDeviceCode(ctx context.Context, r fosite.Requester, code string) (err error) {
+	return t.devHmac.ValidateDeviceCode(ctx, r, code)
+}
+
+func (t TokenStrategy) UserCodeSignature(ctx context.Context, token string) (signature string, err error) {
+	return t.devHmac.UserCodeSignature(ctx, token)
+}
+
+func (t *TokenStrategy) GenerateUserCode(ctx context.Context) (token string, signature string, err error) {
+	return t.devHmac.GenerateUserCode(ctx)
+}
+
+func (t *TokenStrategy) ValidateUserCode(context context.Context, r fosite.Requester, code string) (err error) {
+	return t.devHmac.ValidateUserCode(context, r, code)
+}
diff --git a/go.mod b/go.mod
index a1f2acf17b..b858b19a4f 100644
--- a/go.mod
+++ b/go.mod
@@ -13,6 +13,8 @@ replace (
 
 replace github.com/ory/hydra-client-go/v2 => ./internal/httpclient
 
+replace github.com/ory/fosite => github.com/BuzzBumbleBee/fosite v0.0.0-20230418073244-8a2cf5c8eb98
+
 require (
 	github.com/ThalesIgnite/crypto11 v1.2.4
 	github.com/bradleyjkemp/cupaloy/v2 v2.8.0
diff --git a/go.sum b/go.sum
index 937e44b9ef..7dbd1cdf9f 100644
--- a/go.sum
+++ b/go.sum
@@ -40,6 +40,8 @@ github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOEl
 github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
 github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
 github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=
+github.com/BuzzBumbleBee/fosite v0.0.0-20230418073244-8a2cf5c8eb98 h1:++B7NnQ9jtZoopZVTd/DlU27TcxeyceZb4PWVWvLnro=
+github.com/BuzzBumbleBee/fosite v0.0.0-20230418073244-8a2cf5c8eb98/go.mod h1:N0WZtyPBAuXedTpwzbKl4tSYU8wpjlMQoxnKcL2m8dU=
 github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=
 github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=
 github.com/Masterminds/semver v1.4.2/go.mod h1:MB6lktGJrhw8PrUyiEoblNEGEQ+RzHPF078ddwwvV3Y=
diff --git a/internal/.hydra.yaml b/internal/.hydra.yaml
index bb02d986ad..244a18a3c5 100644
--- a/internal/.hydra.yaml
+++ b/internal/.hydra.yaml
@@ -74,6 +74,7 @@ webfinger:
     auth_url: https://example.com/auth
     token_url: https://example.com/token
     client_registration_url: https://example.com
+    device_authorization_url: https://example.com/device_authorization
     supported_claims:
       - username
     supported_scope:
@@ -99,7 +100,9 @@ urls:
   login: https://login
   consent: https://consent
   logout: https://logout
+  device: https://device
   error: https://error
+  post_device_done: https://post_device
   post_logout_redirect: https://post_logout
 
 strategies:
@@ -112,9 +115,12 @@ ttl:
   refresh_token: 2h
   id_token: 2h
   auth_code: 2h
+  device_user_code: 2h
 
 oauth2:
   expose_internal_errors: true
+  device_authorization:
+    token_polling_interval: 2h
   hashers:
     bcrypt:
       cost: 20
diff --git a/internal/config/config.yaml b/internal/config/config.yaml
index f3e8bff399..f57d0e16e7 100644
--- a/internal/config/config.yaml
+++ b/internal/config/config.yaml
@@ -348,6 +348,10 @@ urls:
     # to the issuer value. If left unspecified, it falls back to the issuer value.
     public: https://localhost:4444/
 
+    # This is the device endpoint location of your Ory Hydra installation.
+    # If left unspecified, it falls back to /device value.
+    device: https://localhost:4444/device
+
   # Sets the login endpoint of the User Login & Consent flow. Defaults to an internal fallback URL.
   login: https://my-login.app/login
   # Sets the consent endpoint of the User Login & Consent flow. Defaults to an internal fallback URL.
@@ -359,6 +363,8 @@ urls:
   error: https://my-error.app/error
   # When a user agent requests to logout, it will be redirected to this url afterwards per default.
   post_logout_redirect: https://my-example.app/logout-successful
+  # When a user agent requests to device auth flow, it will be redirected to this url after a sucessfull login per default.
+  post_device_done: https://my-example.app/device-successful
 
 strategies:
   scope: DEPRECATED_HIERARCHICAL_SCOPE_STRATEGY
@@ -381,6 +387,8 @@ ttl:
   id_token: 1h
   # configures how long auth codes are valid. Defaults to 10m.
   auth_code: 10m
+  # configures how long device and user codes are valid. Defaults to 10m.
+  device_user_code: 10m
 
 oauth2:
   # Set this to true if you want to share error debugging information with your OAuth 2.0 clients.
@@ -402,6 +410,9 @@ oauth2:
   session:
     # store encrypted data in database, default true
     encrypt_at_rest: true
+  device_authorization:
+    # configure how often a non-interactive device should poll the device token endpoint, default 5s
+    token_polling_interval: 5s
 
 # The secrets section configures secrets used for encryption and signing of several systems. All secrets can be rotated,
 # for more information on this topic navigate to:
diff --git a/internal/httpclient/.openapi-generator/FILES b/internal/httpclient/.openapi-generator/FILES
index c83b13fa73..9a28bcde1b 100644
--- a/internal/httpclient/.openapi-generator/FILES
+++ b/internal/httpclient/.openapi-generator/FILES
@@ -7,6 +7,7 @@ api_jwk.go
 api_metadata.go
 api_o_auth2.go
 api_oidc.go
+api_v0alpha2.go
 api_wellknown.go
 client.go
 configuration.go
@@ -14,6 +15,8 @@ docs/AcceptOAuth2ConsentRequest.md
 docs/AcceptOAuth2ConsentRequestSession.md
 docs/AcceptOAuth2LoginRequest.md
 docs/CreateJsonWebKeySet.md
+docs/DeviceAuthorization.md
+docs/DeviceGrantRequest.md
 docs/ErrorOAuth2.md
 docs/GenericError.md
 docs/GetVersion200Response.md
@@ -51,6 +54,8 @@ docs/TokenPaginationResponseHeaders.md
 docs/TrustOAuth2JwtGrantIssuer.md
 docs/TrustedOAuth2JwtGrantIssuer.md
 docs/TrustedOAuth2JwtGrantJsonWebKey.md
+docs/V0alpha2Api.md
+docs/VerifyUserCodeRequest.md
 docs/Version.md
 docs/WellknownApi.md
 git_push.sh
@@ -60,6 +65,8 @@ model_accept_o_auth2_consent_request.go
 model_accept_o_auth2_consent_request_session.go
 model_accept_o_auth2_login_request.go
 model_create_json_web_key_set.go
+model_device_authorization.go
+model_device_grant_request.go
 model_error_o_auth2.go
 model_generic_error.go
 model_get_version_200_response.go
@@ -93,6 +100,7 @@ model_token_pagination_response_headers.go
 model_trust_o_auth2_jwt_grant_issuer.go
 model_trusted_o_auth2_jwt_grant_issuer.go
 model_trusted_o_auth2_jwt_grant_json_web_key.go
+model_verify_user_code_request.go
 model_version.go
 response.go
 utils.go
diff --git a/internal/httpclient/README.md b/internal/httpclient/README.md
index f72f589f45..f2ad21363d 100644
--- a/internal/httpclient/README.md
+++ b/internal/httpclient/README.md
@@ -117,6 +117,7 @@ Class | Method | HTTP request | Description
 *OAuth2Api* | [**SetOAuth2Client**](docs/OAuth2Api.md#setoauth2client) | **Put** /admin/clients/{id} | Set OAuth 2.0 Client
 *OAuth2Api* | [**SetOAuth2ClientLifespans**](docs/OAuth2Api.md#setoauth2clientlifespans) | **Put** /admin/clients/{id}/lifespans | Set OAuth2 Client Token Lifespans
 *OAuth2Api* | [**TrustOAuth2JwtGrantIssuer**](docs/OAuth2Api.md#trustoauth2jwtgrantissuer) | **Post** /admin/trust/grants/jwt-bearer/issuers | Trust OAuth2 JWT Bearer Grant Type Issuer
+*OAuth2Api* | [**VerifyUserCodeRequest**](docs/OAuth2Api.md#verifyusercoderequest) | **Put** /admin/oauth2/auth/requests/device/verify | Verifies a device grant request
 *OidcApi* | [**CreateOidcDynamicClient**](docs/OidcApi.md#createoidcdynamicclient) | **Post** /oauth2/register | Register OAuth2 Client using OpenID Dynamic Client Registration
 *OidcApi* | [**DeleteOidcDynamicClient**](docs/OidcApi.md#deleteoidcdynamicclient) | **Delete** /oauth2/register/{id} | Delete OAuth 2.0 Client using the OpenID Dynamic Client Registration Management Protocol
 *OidcApi* | [**DiscoverOidcConfiguration**](docs/OidcApi.md#discoveroidcconfiguration) | **Get** /.well-known/openid-configuration | OpenID Connect Discovery
@@ -124,6 +125,7 @@ Class | Method | HTTP request | Description
 *OidcApi* | [**GetOidcUserInfo**](docs/OidcApi.md#getoidcuserinfo) | **Get** /userinfo | OpenID Connect Userinfo
 *OidcApi* | [**RevokeOidcSession**](docs/OidcApi.md#revokeoidcsession) | **Get** /oauth2/sessions/logout | OpenID Connect Front- and Back-channel Enabled Logout
 *OidcApi* | [**SetOidcDynamicClient**](docs/OidcApi.md#setoidcdynamicclient) | **Put** /oauth2/register/{id} | Set OAuth2 Client using OpenID Dynamic Client Registration
+*V0alpha2Api* | [**PerformOAuth2DeviceFlow**](docs/V0alpha2Api.md#performoauth2deviceflow) | **Get** /oauth2/device/auth | The OAuth 2.0 Device Authorize Endpoint
 *WellknownApi* | [**DiscoverJsonWebKeys**](docs/WellknownApi.md#discoverjsonwebkeys) | **Get** /.well-known/jwks.json | Discover Well-Known JSON Web Keys
 
 
@@ -133,6 +135,8 @@ Class | Method | HTTP request | Description
  - [AcceptOAuth2ConsentRequestSession](docs/AcceptOAuth2ConsentRequestSession.md)
  - [AcceptOAuth2LoginRequest](docs/AcceptOAuth2LoginRequest.md)
  - [CreateJsonWebKeySet](docs/CreateJsonWebKeySet.md)
+ - [DeviceAuthorization](docs/DeviceAuthorization.md)
+ - [DeviceGrantRequest](docs/DeviceGrantRequest.md)
  - [ErrorOAuth2](docs/ErrorOAuth2.md)
  - [GenericError](docs/GenericError.md)
  - [GetVersion200Response](docs/GetVersion200Response.md)
@@ -166,6 +170,7 @@ Class | Method | HTTP request | Description
  - [TrustOAuth2JwtGrantIssuer](docs/TrustOAuth2JwtGrantIssuer.md)
  - [TrustedOAuth2JwtGrantIssuer](docs/TrustedOAuth2JwtGrantIssuer.md)
  - [TrustedOAuth2JwtGrantJsonWebKey](docs/TrustedOAuth2JwtGrantJsonWebKey.md)
+ - [VerifyUserCodeRequest](docs/VerifyUserCodeRequest.md)
  - [Version](docs/Version.md)
 
 
diff --git a/internal/httpclient/api/openapi.yaml b/internal/httpclient/api/openapi.yaml
index f7c19f50c4..32ad824ae7 100644
--- a/internal/httpclient/api/openapi.yaml
+++ b/internal/httpclient/api/openapi.yaml
@@ -786,6 +786,40 @@ paths:
       summary: Reject OAuth 2.0 Consent Request
       tags:
       - oAuth2
+  /admin/oauth2/auth/requests/device/verify:
+    put:
+      description: Verifies a device grant request
+      operationId: verifyUserCodeRequest
+      parameters:
+      - explode: true
+        in: query
+        name: device_challenge
+        required: true
+        schema:
+          type: string
+        style: form
+      requestBody:
+        content:
+          application/json:
+            schema:
+              $ref: '#/components/schemas/verifyUserCodeRequest'
+        x-originalParamName: Body
+      responses:
+        "200":
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/oAuth2RedirectTo'
+          description: oAuth2RedirectTo
+        default:
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/errorOAuth2'
+          description: errorOAuth2
+      summary: Verifies a device grant request
+      tags:
+      - oAuth2
   /admin/oauth2/auth/requests/login:
     get:
       description: "When an authorization code, hybrid, or implicit OAuth 2.0 Flow\
@@ -1437,6 +1471,29 @@ paths:
       summary: OAuth 2.0 Authorize Endpoint
       tags:
       - oAuth2
+  /oauth2/device/auth:
+    get:
+      description: "This endpoint is not documented here because you should never\
+        \ use your own implementation to perform OAuth2 flows.\nOAuth2 is a very popular\
+        \ protocol and a library for your programming language will exists.\n\nTo\
+        \ learn more about this flow please refer to the specification: https://tools.ietf.org/html/rfc8628"
+      operationId: performOAuth2DeviceFlow
+      responses:
+        "200":
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/deviceAuthorization'
+          description: deviceAuthorization
+        default:
+          content:
+            application/json:
+              schema:
+                $ref: '#/components/schemas/errorOAuth2'
+          description: errorOAuth2
+      summary: The OAuth 2.0 Device Authorize Endpoint
+      tags:
+      - v0alpha2
   /oauth2/register:
     post:
       description: |-
@@ -1803,6 +1860,11 @@ components:
       title: "StringSliceJSONFormat represents []string{} which is encoded to/from\
         \ JSON for SQL storage."
       type: array
+    StringSlicePipeDelimiter:
+      items:
+        type: string
+      title: StringSlicePipeDelimiter de/encodes the string slice to/from a SQL string.
+      type: array
     Time:
       format: date-time
       type: string
@@ -1950,6 +2012,86 @@ components:
       - kid
       - use
       type: object
+    deviceAuthorization:
+      description: '# Ory''s OAuth 2.0 Device Authorization API'
+      example:
+        user_code: AAAAAA
+        device_code: ory_dc_smldfksmdfkl.mslkmlkmlk
+        interval: 5
+        verification_uri_complete: https://auth.ory.sh/tv?user_code=AAAAAA
+        verification_uri: https://auth.ory.sh/tv
+        expires_in: 16830
+      properties:
+        device_code:
+          description: The device verification code.
+          example: ory_dc_smldfksmdfkl.mslkmlkmlk
+          type: string
+        expires_in:
+          description: The lifetime in seconds of the "device_code" and "user_code".
+          example: 16830
+          format: int64
+          type: integer
+        interval:
+          description: "The minimum amount of time in seconds that the client\nSHOULD\
+            \ wait between polling requests to the token endpoint.  If no\nvalue is\
+            \ provided, clients MUST use 5 as the default."
+          example: 5
+          format: int64
+          type: integer
+        user_code:
+          description: The end-user verification code.
+          example: AAAAAA
+          type: string
+        verification_uri:
+          description: |-
+            The end-user verification URI on the authorization
+            server.  The URI should be short and easy to remember as end users
+            will be asked to manually type it into their user agent.
+          example: https://auth.ory.sh/tv
+          type: string
+        verification_uri_complete:
+          description: "A verification URI that includes the \"user_code\" (or\nother\
+            \ information with the same function as the \"user_code\"),\nwhich is\
+            \ designed for non-textual transmission."
+          example: https://auth.ory.sh/tv?user_code=AAAAAA
+          type: string
+      title: OAuth2 Device Flow
+      type: object
+    deviceGrantRequest:
+      properties:
+        challenge:
+          description: |-
+            ID is the identifier ("device challenge") of the device grant request. It is used to
+            identify the session.
+          type: string
+        client:
+          $ref: '#/components/schemas/oAuth2Client'
+        handled_at:
+          format: date-time
+          title: NullTime implements sql.NullTime functionality.
+          type: string
+        request_url:
+          description: RequestURL is the original Device Grant URL requested.
+          type: string
+        requested_access_token_audience:
+          items:
+            type: string
+          title: StringSlicePipeDelimiter de/encodes the string slice to/from a SQL
+            string.
+          type: array
+        requested_scope:
+          items:
+            type: string
+          title: StringSlicePipeDelimiter de/encodes the string slice to/from a SQL
+            string.
+          type: array
+      required:
+      - challenge
+      - client
+      - requested_access_token_audience
+      - requested_scope
+      title: Contains information on an ongoing device grant request.
+      type: object
     errorOAuth2:
       description: Error
       example:
@@ -3495,6 +3637,7 @@ components:
         - userinfo_signed_response_alg
         - userinfo_signed_response_alg
         authorization_endpoint: https://playground.ory.sh/ory-hydra/public/oauth2/auth
+        device_authorization_endpoint: device_authorization_endpoint
         claims_supported:
         - claims_supported
         - claims_supported
@@ -3575,6 +3718,9 @@ components:
           items:
             type: string
           type: array
+        device_authorization_endpoint:
+          description: URL of the authorization server's device authorization endpoint
+          type: string
         end_session_endpoint:
           description: |-
             OpenID Connect End-Session Endpoint
@@ -4145,6 +4291,12 @@ components:
           example: https://jwt-idp.example.com
           type: string
       type: object
+    verifyUserCodeRequest:
+      description: Contains information on an device verification
+      properties:
+        user_code:
+          type: string
+      type: object
     unexpectedError:
       type: string
     version:
diff --git a/internal/httpclient/api_o_auth2.go b/internal/httpclient/api_o_auth2.go
index 72cd325cd0..6b93b4f4d3 100644
--- a/internal/httpclient/api_o_auth2.go
+++ b/internal/httpclient/api_o_auth2.go
@@ -3598,3 +3598,128 @@ func (a *OAuth2ApiService) TrustOAuth2JwtGrantIssuerExecute(r ApiTrustOAuth2JwtG
 
 	return localVarReturnValue, localVarHTTPResponse, nil
 }
+
+type ApiVerifyUserCodeRequestRequest struct {
+	ctx                   context.Context
+	ApiService            *OAuth2ApiService
+	deviceChallenge       *string
+	verifyUserCodeRequest *VerifyUserCodeRequest
+}
+
+func (r ApiVerifyUserCodeRequestRequest) DeviceChallenge(deviceChallenge string) ApiVerifyUserCodeRequestRequest {
+	r.deviceChallenge = &deviceChallenge
+	return r
+}
+
+func (r ApiVerifyUserCodeRequestRequest) VerifyUserCodeRequest(verifyUserCodeRequest VerifyUserCodeRequest) ApiVerifyUserCodeRequestRequest {
+	r.verifyUserCodeRequest = &verifyUserCodeRequest
+	return r
+}
+
+func (r ApiVerifyUserCodeRequestRequest) Execute() (*OAuth2RedirectTo, *http.Response, error) {
+	return r.ApiService.VerifyUserCodeRequestExecute(r)
+}
+
+/*
+VerifyUserCodeRequest Verifies a device grant request
+
+Verifies a device grant request
+
+	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
+	@return ApiVerifyUserCodeRequestRequest
+*/
+func (a *OAuth2ApiService) VerifyUserCodeRequest(ctx context.Context) ApiVerifyUserCodeRequestRequest {
+	return ApiVerifyUserCodeRequestRequest{
+		ApiService: a,
+		ctx:        ctx,
+	}
+}
+
+// Execute executes the request
+//
+//	@return OAuth2RedirectTo
+func (a *OAuth2ApiService) VerifyUserCodeRequestExecute(r ApiVerifyUserCodeRequestRequest) (*OAuth2RedirectTo, *http.Response, error) {
+	var (
+		localVarHTTPMethod  = http.MethodPut
+		localVarPostBody    interface{}
+		formFiles           []formFile
+		localVarReturnValue *OAuth2RedirectTo
+	)
+
+	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OAuth2ApiService.VerifyUserCodeRequest")
+	if err != nil {
+		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
+	}
+
+	localVarPath := localBasePath + "/admin/oauth2/auth/requests/device/verify"
+
+	localVarHeaderParams := make(map[string]string)
+	localVarQueryParams := url.Values{}
+	localVarFormParams := url.Values{}
+	if r.deviceChallenge == nil {
+		return localVarReturnValue, nil, reportError("deviceChallenge is required and must be specified")
+	}
+
+	localVarQueryParams.Add("device_challenge", parameterToString(*r.deviceChallenge, ""))
+	// to determine the Content-Type header
+	localVarHTTPContentTypes := []string{"application/json"}
+
+	// set Content-Type header
+	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
+	if localVarHTTPContentType != "" {
+		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
+	}
+
+	// to determine the Accept header
+	localVarHTTPHeaderAccepts := []string{"application/json"}
+
+	// set Accept header
+	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
+	if localVarHTTPHeaderAccept != "" {
+		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
+	}
+	// body params
+	localVarPostBody = r.verifyUserCodeRequest
+	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
+	if err != nil {
+		return localVarReturnValue, nil, err
+	}
+
+	localVarHTTPResponse, err := a.client.callAPI(req)
+	if err != nil || localVarHTTPResponse == nil {
+		return localVarReturnValue, localVarHTTPResponse, err
+	}
+
+	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
+	localVarHTTPResponse.Body.Close()
+	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
+	if err != nil {
+		return localVarReturnValue, localVarHTTPResponse, err
+	}
+
+	if localVarHTTPResponse.StatusCode >= 300 {
+		newErr := &GenericOpenAPIError{
+			body:  localVarBody,
+			error: localVarHTTPResponse.Status,
+		}
+		var v ErrorOAuth2
+		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
+		if err != nil {
+			newErr.error = err.Error()
+			return localVarReturnValue, localVarHTTPResponse, newErr
+		}
+		newErr.model = v
+		return localVarReturnValue, localVarHTTPResponse, newErr
+	}
+
+	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
+	if err != nil {
+		newErr := &GenericOpenAPIError{
+			body:  localVarBody,
+			error: err.Error(),
+		}
+		return localVarReturnValue, localVarHTTPResponse, newErr
+	}
+
+	return localVarReturnValue, localVarHTTPResponse, nil
+}
diff --git a/internal/httpclient/api_v0alpha2.go b/internal/httpclient/api_v0alpha2.go
new file mode 100644
index 0000000000..37b8174a3a
--- /dev/null
+++ b/internal/httpclient/api_v0alpha2.go
@@ -0,0 +1,133 @@
+/*
+Ory Hydra API
+
+Documentation for all of Ory Hydra's APIs.
+
+API version:
+Contact: hi@ory.sh
+*/
+
+// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
+
+package openapi
+
+import (
+	"bytes"
+	"context"
+	"io/ioutil"
+	"net/http"
+	"net/url"
+)
+
+// V0alpha2ApiService V0alpha2Api service
+type V0alpha2ApiService service
+
+type ApiPerformOAuth2DeviceFlowRequest struct {
+	ctx        context.Context
+	ApiService *V0alpha2ApiService
+}
+
+func (r ApiPerformOAuth2DeviceFlowRequest) Execute() (*DeviceAuthorization, *http.Response, error) {
+	return r.ApiService.PerformOAuth2DeviceFlowExecute(r)
+}
+
+/*
+PerformOAuth2DeviceFlow The OAuth 2.0 Device Authorize Endpoint
+
+This endpoint is not documented here because you should never use your own implementation to perform OAuth2 flows.
+OAuth2 is a very popular protocol and a library for your programming language will exists.
+
+To learn more about this flow please refer to the specification: https://tools.ietf.org/html/rfc8628
+
+	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
+	@return ApiPerformOAuth2DeviceFlowRequest
+*/
+func (a *V0alpha2ApiService) PerformOAuth2DeviceFlow(ctx context.Context) ApiPerformOAuth2DeviceFlowRequest {
+	return ApiPerformOAuth2DeviceFlowRequest{
+		ApiService: a,
+		ctx:        ctx,
+	}
+}
+
+// Execute executes the request
+//
+//	@return DeviceAuthorization
+func (a *V0alpha2ApiService) PerformOAuth2DeviceFlowExecute(r ApiPerformOAuth2DeviceFlowRequest) (*DeviceAuthorization, *http.Response, error) {
+	var (
+		localVarHTTPMethod  = http.MethodGet
+		localVarPostBody    interface{}
+		formFiles           []formFile
+		localVarReturnValue *DeviceAuthorization
+	)
+
+	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V0alpha2ApiService.PerformOAuth2DeviceFlow")
+	if err != nil {
+		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
+	}
+
+	localVarPath := localBasePath + "/oauth2/device/auth"
+
+	localVarHeaderParams := make(map[string]string)
+	localVarQueryParams := url.Values{}
+	localVarFormParams := url.Values{}
+
+	// to determine the Content-Type header
+	localVarHTTPContentTypes := []string{}
+
+	// set Content-Type header
+	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
+	if localVarHTTPContentType != "" {
+		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
+	}
+
+	// to determine the Accept header
+	localVarHTTPHeaderAccepts := []string{"application/json"}
+
+	// set Accept header
+	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
+	if localVarHTTPHeaderAccept != "" {
+		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
+	}
+	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
+	if err != nil {
+		return localVarReturnValue, nil, err
+	}
+
+	localVarHTTPResponse, err := a.client.callAPI(req)
+	if err != nil || localVarHTTPResponse == nil {
+		return localVarReturnValue, localVarHTTPResponse, err
+	}
+
+	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
+	localVarHTTPResponse.Body.Close()
+	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
+	if err != nil {
+		return localVarReturnValue, localVarHTTPResponse, err
+	}
+
+	if localVarHTTPResponse.StatusCode >= 300 {
+		newErr := &GenericOpenAPIError{
+			body:  localVarBody,
+			error: localVarHTTPResponse.Status,
+		}
+		var v ErrorOAuth2
+		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
+		if err != nil {
+			newErr.error = err.Error()
+			return localVarReturnValue, localVarHTTPResponse, newErr
+		}
+		newErr.model = v
+		return localVarReturnValue, localVarHTTPResponse, newErr
+	}
+
+	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
+	if err != nil {
+		newErr := &GenericOpenAPIError{
+			body:  localVarBody,
+			error: err.Error(),
+		}
+		return localVarReturnValue, localVarHTTPResponse, newErr
+	}
+
+	return localVarReturnValue, localVarHTTPResponse, nil
+}
diff --git a/internal/httpclient/client.go b/internal/httpclient/client.go
index fe7ccccad0..2aea075c66 100644
--- a/internal/httpclient/client.go
+++ b/internal/httpclient/client.go
@@ -58,6 +58,8 @@ type APIClient struct {
 
 	OidcApi *OidcApiService
 
+	V0alpha2Api *V0alpha2ApiService
+
 	WellknownApi *WellknownApiService
 }
 
@@ -81,6 +83,7 @@ func NewAPIClient(cfg *Configuration) *APIClient {
 	c.MetadataApi = (*MetadataApiService)(&c.common)
 	c.OAuth2Api = (*OAuth2ApiService)(&c.common)
 	c.OidcApi = (*OidcApiService)(&c.common)
+	c.V0alpha2Api = (*V0alpha2ApiService)(&c.common)
 	c.WellknownApi = (*WellknownApiService)(&c.common)
 
 	return c
diff --git a/internal/httpclient/docs/DeviceAuthorization.md b/internal/httpclient/docs/DeviceAuthorization.md
new file mode 100644
index 0000000000..4ba933a4b2
--- /dev/null
+++ b/internal/httpclient/docs/DeviceAuthorization.md
@@ -0,0 +1,186 @@
+# DeviceAuthorization
+
+## Properties
+
+Name | Type | Description | Notes
+------------ | ------------- | ------------- | -------------
+**DeviceCode** | Pointer to **string** | The device verification code. | [optional] 
+**ExpiresIn** | Pointer to **int64** | The lifetime in seconds of the \&quot;device_code\&quot; and \&quot;user_code\&quot;. | [optional] 
+**Interval** | Pointer to **int64** | The minimum amount of time in seconds that the client SHOULD wait between polling requests to the token endpoint.  If no value is provided, clients MUST use 5 as the default. | [optional] 
+**UserCode** | Pointer to **string** | The end-user verification code. | [optional] 
+**VerificationUri** | Pointer to **string** | The end-user verification URI on the authorization server.  The URI should be short and easy to remember as end users will be asked to manually type it into their user agent. | [optional] 
+**VerificationUriComplete** | Pointer to **string** | A verification URI that includes the \&quot;user_code\&quot; (or other information with the same function as the \&quot;user_code\&quot;), which is designed for non-textual transmission. | [optional] 
+
+## Methods
+
+### NewDeviceAuthorization
+
+`func NewDeviceAuthorization() *DeviceAuthorization`
+
+NewDeviceAuthorization instantiates a new DeviceAuthorization object
+This constructor will assign default values to properties that have it defined,
+and makes sure properties required by API are set, but the set of arguments
+will change when the set of required properties is changed
+
+### NewDeviceAuthorizationWithDefaults
+
+`func NewDeviceAuthorizationWithDefaults() *DeviceAuthorization`
+
+NewDeviceAuthorizationWithDefaults instantiates a new DeviceAuthorization object
+This constructor will only assign default values to properties that have it defined,
+but it doesn't guarantee that properties required by API are set
+
+### GetDeviceCode
+
+`func (o *DeviceAuthorization) GetDeviceCode() string`
+
+GetDeviceCode returns the DeviceCode field if non-nil, zero value otherwise.
+
+### GetDeviceCodeOk
+
+`func (o *DeviceAuthorization) GetDeviceCodeOk() (*string, bool)`
+
+GetDeviceCodeOk returns a tuple with the DeviceCode field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetDeviceCode
+
+`func (o *DeviceAuthorization) SetDeviceCode(v string)`
+
+SetDeviceCode sets DeviceCode field to given value.
+
+### HasDeviceCode
+
+`func (o *DeviceAuthorization) HasDeviceCode() bool`
+
+HasDeviceCode returns a boolean if a field has been set.
+
+### GetExpiresIn
+
+`func (o *DeviceAuthorization) GetExpiresIn() int64`
+
+GetExpiresIn returns the ExpiresIn field if non-nil, zero value otherwise.
+
+### GetExpiresInOk
+
+`func (o *DeviceAuthorization) GetExpiresInOk() (*int64, bool)`
+
+GetExpiresInOk returns a tuple with the ExpiresIn field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetExpiresIn
+
+`func (o *DeviceAuthorization) SetExpiresIn(v int64)`
+
+SetExpiresIn sets ExpiresIn field to given value.
+
+### HasExpiresIn
+
+`func (o *DeviceAuthorization) HasExpiresIn() bool`
+
+HasExpiresIn returns a boolean if a field has been set.
+
+### GetInterval
+
+`func (o *DeviceAuthorization) GetInterval() int64`
+
+GetInterval returns the Interval field if non-nil, zero value otherwise.
+
+### GetIntervalOk
+
+`func (o *DeviceAuthorization) GetIntervalOk() (*int64, bool)`
+
+GetIntervalOk returns a tuple with the Interval field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetInterval
+
+`func (o *DeviceAuthorization) SetInterval(v int64)`
+
+SetInterval sets Interval field to given value.
+
+### HasInterval
+
+`func (o *DeviceAuthorization) HasInterval() bool`
+
+HasInterval returns a boolean if a field has been set.
+
+### GetUserCode
+
+`func (o *DeviceAuthorization) GetUserCode() string`
+
+GetUserCode returns the UserCode field if non-nil, zero value otherwise.
+
+### GetUserCodeOk
+
+`func (o *DeviceAuthorization) GetUserCodeOk() (*string, bool)`
+
+GetUserCodeOk returns a tuple with the UserCode field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetUserCode
+
+`func (o *DeviceAuthorization) SetUserCode(v string)`
+
+SetUserCode sets UserCode field to given value.
+
+### HasUserCode
+
+`func (o *DeviceAuthorization) HasUserCode() bool`
+
+HasUserCode returns a boolean if a field has been set.
+
+### GetVerificationUri
+
+`func (o *DeviceAuthorization) GetVerificationUri() string`
+
+GetVerificationUri returns the VerificationUri field if non-nil, zero value otherwise.
+
+### GetVerificationUriOk
+
+`func (o *DeviceAuthorization) GetVerificationUriOk() (*string, bool)`
+
+GetVerificationUriOk returns a tuple with the VerificationUri field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetVerificationUri
+
+`func (o *DeviceAuthorization) SetVerificationUri(v string)`
+
+SetVerificationUri sets VerificationUri field to given value.
+
+### HasVerificationUri
+
+`func (o *DeviceAuthorization) HasVerificationUri() bool`
+
+HasVerificationUri returns a boolean if a field has been set.
+
+### GetVerificationUriComplete
+
+`func (o *DeviceAuthorization) GetVerificationUriComplete() string`
+
+GetVerificationUriComplete returns the VerificationUriComplete field if non-nil, zero value otherwise.
+
+### GetVerificationUriCompleteOk
+
+`func (o *DeviceAuthorization) GetVerificationUriCompleteOk() (*string, bool)`
+
+GetVerificationUriCompleteOk returns a tuple with the VerificationUriComplete field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetVerificationUriComplete
+
+`func (o *DeviceAuthorization) SetVerificationUriComplete(v string)`
+
+SetVerificationUriComplete sets VerificationUriComplete field to given value.
+
+### HasVerificationUriComplete
+
+`func (o *DeviceAuthorization) HasVerificationUriComplete() bool`
+
+HasVerificationUriComplete returns a boolean if a field has been set.
+
+
+[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)
+
+
diff --git a/internal/httpclient/docs/DeviceGrantRequest.md b/internal/httpclient/docs/DeviceGrantRequest.md
new file mode 100644
index 0000000000..57723ef98a
--- /dev/null
+++ b/internal/httpclient/docs/DeviceGrantRequest.md
@@ -0,0 +1,166 @@
+# DeviceGrantRequest
+
+## Properties
+
+Name | Type | Description | Notes
+------------ | ------------- | ------------- | -------------
+**Challenge** | **string** | ID is the identifier (\&quot;device challenge\&quot;) of the device grant request. It is used to identify the session. | 
+**Client** | [**OAuth2Client**](OAuth2Client.md) |  | 
+**HandledAt** | Pointer to **time.Time** |  | [optional] 
+**RequestUrl** | Pointer to **string** | RequestURL is the original Device Grant URL requested. | [optional] 
+**RequestedAccessTokenAudience** | **[]string** |  | 
+**RequestedScope** | **[]string** |  | 
+
+## Methods
+
+### NewDeviceGrantRequest
+
+`func NewDeviceGrantRequest(challenge string, client OAuth2Client, requestedAccessTokenAudience []string, requestedScope []string, ) *DeviceGrantRequest`
+
+NewDeviceGrantRequest instantiates a new DeviceGrantRequest object
+This constructor will assign default values to properties that have it defined,
+and makes sure properties required by API are set, but the set of arguments
+will change when the set of required properties is changed
+
+### NewDeviceGrantRequestWithDefaults
+
+`func NewDeviceGrantRequestWithDefaults() *DeviceGrantRequest`
+
+NewDeviceGrantRequestWithDefaults instantiates a new DeviceGrantRequest object
+This constructor will only assign default values to properties that have it defined,
+but it doesn't guarantee that properties required by API are set
+
+### GetChallenge
+
+`func (o *DeviceGrantRequest) GetChallenge() string`
+
+GetChallenge returns the Challenge field if non-nil, zero value otherwise.
+
+### GetChallengeOk
+
+`func (o *DeviceGrantRequest) GetChallengeOk() (*string, bool)`
+
+GetChallengeOk returns a tuple with the Challenge field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetChallenge
+
+`func (o *DeviceGrantRequest) SetChallenge(v string)`
+
+SetChallenge sets Challenge field to given value.
+
+
+### GetClient
+
+`func (o *DeviceGrantRequest) GetClient() OAuth2Client`
+
+GetClient returns the Client field if non-nil, zero value otherwise.
+
+### GetClientOk
+
+`func (o *DeviceGrantRequest) GetClientOk() (*OAuth2Client, bool)`
+
+GetClientOk returns a tuple with the Client field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetClient
+
+`func (o *DeviceGrantRequest) SetClient(v OAuth2Client)`
+
+SetClient sets Client field to given value.
+
+
+### GetHandledAt
+
+`func (o *DeviceGrantRequest) GetHandledAt() time.Time`
+
+GetHandledAt returns the HandledAt field if non-nil, zero value otherwise.
+
+### GetHandledAtOk
+
+`func (o *DeviceGrantRequest) GetHandledAtOk() (*time.Time, bool)`
+
+GetHandledAtOk returns a tuple with the HandledAt field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetHandledAt
+
+`func (o *DeviceGrantRequest) SetHandledAt(v time.Time)`
+
+SetHandledAt sets HandledAt field to given value.
+
+### HasHandledAt
+
+`func (o *DeviceGrantRequest) HasHandledAt() bool`
+
+HasHandledAt returns a boolean if a field has been set.
+
+### GetRequestUrl
+
+`func (o *DeviceGrantRequest) GetRequestUrl() string`
+
+GetRequestUrl returns the RequestUrl field if non-nil, zero value otherwise.
+
+### GetRequestUrlOk
+
+`func (o *DeviceGrantRequest) GetRequestUrlOk() (*string, bool)`
+
+GetRequestUrlOk returns a tuple with the RequestUrl field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetRequestUrl
+
+`func (o *DeviceGrantRequest) SetRequestUrl(v string)`
+
+SetRequestUrl sets RequestUrl field to given value.
+
+### HasRequestUrl
+
+`func (o *DeviceGrantRequest) HasRequestUrl() bool`
+
+HasRequestUrl returns a boolean if a field has been set.
+
+### GetRequestedAccessTokenAudience
+
+`func (o *DeviceGrantRequest) GetRequestedAccessTokenAudience() []string`
+
+GetRequestedAccessTokenAudience returns the RequestedAccessTokenAudience field if non-nil, zero value otherwise.
+
+### GetRequestedAccessTokenAudienceOk
+
+`func (o *DeviceGrantRequest) GetRequestedAccessTokenAudienceOk() (*[]string, bool)`
+
+GetRequestedAccessTokenAudienceOk returns a tuple with the RequestedAccessTokenAudience field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetRequestedAccessTokenAudience
+
+`func (o *DeviceGrantRequest) SetRequestedAccessTokenAudience(v []string)`
+
+SetRequestedAccessTokenAudience sets RequestedAccessTokenAudience field to given value.
+
+
+### GetRequestedScope
+
+`func (o *DeviceGrantRequest) GetRequestedScope() []string`
+
+GetRequestedScope returns the RequestedScope field if non-nil, zero value otherwise.
+
+### GetRequestedScopeOk
+
+`func (o *DeviceGrantRequest) GetRequestedScopeOk() (*[]string, bool)`
+
+GetRequestedScopeOk returns a tuple with the RequestedScope field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetRequestedScope
+
+`func (o *DeviceGrantRequest) SetRequestedScope(v []string)`
+
+SetRequestedScope sets RequestedScope field to given value.
+
+
+
+[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)
+
+
diff --git a/internal/httpclient/docs/OAuth2Api.md b/internal/httpclient/docs/OAuth2Api.md
index c5b4aff638..51d43ec198 100644
--- a/internal/httpclient/docs/OAuth2Api.md
+++ b/internal/httpclient/docs/OAuth2Api.md
@@ -32,6 +32,7 @@ Method | HTTP request | Description
 [**SetOAuth2Client**](OAuth2Api.md#SetOAuth2Client) | **Put** /admin/clients/{id} | Set OAuth 2.0 Client
 [**SetOAuth2ClientLifespans**](OAuth2Api.md#SetOAuth2ClientLifespans) | **Put** /admin/clients/{id}/lifespans | Set OAuth2 Client Token Lifespans
 [**TrustOAuth2JwtGrantIssuer**](OAuth2Api.md#TrustOAuth2JwtGrantIssuer) | **Post** /admin/trust/grants/jwt-bearer/issuers | Trust OAuth2 JWT Bearer Grant Type Issuer
+[**VerifyUserCodeRequest**](OAuth2Api.md#VerifyUserCodeRequest) | **Put** /admin/oauth2/auth/requests/device/verify | Verifies a device grant request
 
 
 
@@ -1942,3 +1943,71 @@ No authorization required
 [[Back to Model list]](../README.md#documentation-for-models)
 [[Back to README]](../README.md)
 
+
+## VerifyUserCodeRequest
+
+> OAuth2RedirectTo VerifyUserCodeRequest(ctx).DeviceChallenge(deviceChallenge).VerifyUserCodeRequest(verifyUserCodeRequest).Execute()
+
+Verifies a device grant request
+
+
+
+### Example
+
+```go
+package main
+
+import (
+    "context"
+    "fmt"
+    "os"
+    openapiclient "./openapi"
+)
+
+func main() {
+    deviceChallenge := "deviceChallenge_example" // string | 
+    verifyUserCodeRequest := *openapiclient.NewVerifyUserCodeRequest() // VerifyUserCodeRequest |  (optional)
+
+    configuration := openapiclient.NewConfiguration()
+    apiClient := openapiclient.NewAPIClient(configuration)
+    resp, r, err := apiClient.OAuth2Api.VerifyUserCodeRequest(context.Background()).DeviceChallenge(deviceChallenge).VerifyUserCodeRequest(verifyUserCodeRequest).Execute()
+    if err != nil {
+        fmt.Fprintf(os.Stderr, "Error when calling `OAuth2Api.VerifyUserCodeRequest``: %v\n", err)
+        fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
+    }
+    // response from `VerifyUserCodeRequest`: OAuth2RedirectTo
+    fmt.Fprintf(os.Stdout, "Response from `OAuth2Api.VerifyUserCodeRequest`: %v\n", resp)
+}
+```
+
+### Path Parameters
+
+
+
+### Other Parameters
+
+Other parameters are passed through a pointer to a apiVerifyUserCodeRequestRequest struct via the builder pattern
+
+
+Name | Type | Description  | Notes
+------------- | ------------- | ------------- | -------------
+ **deviceChallenge** | **string** |  | 
+ **verifyUserCodeRequest** | [**VerifyUserCodeRequest**](VerifyUserCodeRequest.md) |  | 
+
+### Return type
+
+[**OAuth2RedirectTo**](OAuth2RedirectTo.md)
+
+### Authorization
+
+No authorization required
+
+### HTTP request headers
+
+- **Content-Type**: application/json
+- **Accept**: application/json
+
+[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints)
+[[Back to Model list]](../README.md#documentation-for-models)
+[[Back to README]](../README.md)
+
diff --git a/internal/httpclient/docs/OidcConfiguration.md b/internal/httpclient/docs/OidcConfiguration.md
index 723bd6a8b4..5b919689ba 100644
--- a/internal/httpclient/docs/OidcConfiguration.md
+++ b/internal/httpclient/docs/OidcConfiguration.md
@@ -10,6 +10,7 @@ Name | Type | Description | Notes
 **ClaimsParameterSupported** | Pointer to **bool** | OpenID Connect Claims Parameter Parameter Supported  Boolean value specifying whether the OP supports use of the claims parameter, with true indicating support. | [optional] 
 **ClaimsSupported** | Pointer to **[]string** | OpenID Connect Supported Claims  JSON array containing a list of the Claim Names of the Claims that the OpenID Provider MAY be able to supply values for. Note that for privacy or other reasons, this might not be an exhaustive list. | [optional] 
 **CodeChallengeMethodsSupported** | Pointer to **[]string** | OAuth 2.0 PKCE Supported Code Challenge Methods  JSON array containing a list of Proof Key for Code Exchange (PKCE) [RFC7636] code challenge methods supported by this authorization server. | [optional] 
+**DeviceAuthorizationEndpoint** | Pointer to **string** | URL of the authorization server&#39;s device authorization endpoint | [optional] 
 **EndSessionEndpoint** | Pointer to **string** | OpenID Connect End-Session Endpoint  URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP. | [optional] 
 **FrontchannelLogoutSessionSupported** | Pointer to **bool** | OpenID Connect Front-Channel Logout Session Required  Boolean value specifying whether the OP can pass iss (issuer) and sid (session ID) query parameters to identify the RP session with the OP when the frontchannel_logout_uri is used. If supported, the sid Claim is also included in ID Tokens issued by the OP. | [optional] 
 **FrontchannelLogoutSupported** | Pointer to **bool** | OpenID Connect Front-Channel Logout Supported  Boolean value specifying whether the OP supports HTTP-based logout, with true indicating support. | [optional] 
@@ -198,6 +199,31 @@ SetCodeChallengeMethodsSupported sets CodeChallengeMethodsSupported field to giv
 
 HasCodeChallengeMethodsSupported returns a boolean if a field has been set.
 
+### GetDeviceAuthorizationEndpoint
+
+`func (o *OidcConfiguration) GetDeviceAuthorizationEndpoint() string`
+
+GetDeviceAuthorizationEndpoint returns the DeviceAuthorizationEndpoint field if non-nil, zero value otherwise.
+
+### GetDeviceAuthorizationEndpointOk
+
+`func (o *OidcConfiguration) GetDeviceAuthorizationEndpointOk() (*string, bool)`
+
+GetDeviceAuthorizationEndpointOk returns a tuple with the DeviceAuthorizationEndpoint field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetDeviceAuthorizationEndpoint
+
+`func (o *OidcConfiguration) SetDeviceAuthorizationEndpoint(v string)`
+
+SetDeviceAuthorizationEndpoint sets DeviceAuthorizationEndpoint field to given value.
+
+### HasDeviceAuthorizationEndpoint
+
+`func (o *OidcConfiguration) HasDeviceAuthorizationEndpoint() bool`
+
+HasDeviceAuthorizationEndpoint returns a boolean if a field has been set.
+
 ### GetEndSessionEndpoint
 
 `func (o *OidcConfiguration) GetEndSessionEndpoint() string`
diff --git a/internal/httpclient/docs/V0alpha2Api.md b/internal/httpclient/docs/V0alpha2Api.md
new file mode 100644
index 0000000000..593b0adc85
--- /dev/null
+++ b/internal/httpclient/docs/V0alpha2Api.md
@@ -0,0 +1,70 @@
+# \V0alpha2Api
+
+All URIs are relative to *http://localhost*
+
+Method | HTTP request | Description
+------------- | ------------- | -------------
+[**PerformOAuth2DeviceFlow**](V0alpha2Api.md#PerformOAuth2DeviceFlow) | **Get** /oauth2/device/auth | The OAuth 2.0 Device Authorize Endpoint
+
+
+
+## PerformOAuth2DeviceFlow
+
+> DeviceAuthorization PerformOAuth2DeviceFlow(ctx).Execute()
+
+The OAuth 2.0 Device Authorize Endpoint
+
+
+
+### Example
+
+```go
+package main
+
+import (
+    "context"
+    "fmt"
+    "os"
+    openapiclient "./openapi"
+)
+
+func main() {
+
+    configuration := openapiclient.NewConfiguration()
+    apiClient := openapiclient.NewAPIClient(configuration)
+    resp, r, err := apiClient.V0alpha2Api.PerformOAuth2DeviceFlow(context.Background()).Execute()
+    if err != nil {
+        fmt.Fprintf(os.Stderr, "Error when calling `V0alpha2Api.PerformOAuth2DeviceFlow``: %v\n", err)
+        fmt.Fprintf(os.Stderr, "Full HTTP response: %v\n", r)
+    }
+    // response from `PerformOAuth2DeviceFlow`: DeviceAuthorization
+    fmt.Fprintf(os.Stdout, "Response from `V0alpha2Api.PerformOAuth2DeviceFlow`: %v\n", resp)
+}
+```
+
+### Path Parameters
+
+This endpoint does not need any parameter.
+
+### Other Parameters
+
+Other parameters are passed through a pointer to a apiPerformOAuth2DeviceFlowRequest struct via the builder pattern
+
+
+### Return type
+
+[**DeviceAuthorization**](DeviceAuthorization.md)
+
+### Authorization
+
+No authorization required
+
+### HTTP request headers
+
+- **Content-Type**: Not defined
+- **Accept**: application/json
+
+[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints)
+[[Back to Model list]](../README.md#documentation-for-models)
+[[Back to README]](../README.md)
+
diff --git a/internal/httpclient/docs/VerifyUserCodeRequest.md b/internal/httpclient/docs/VerifyUserCodeRequest.md
new file mode 100644
index 0000000000..021874d194
--- /dev/null
+++ b/internal/httpclient/docs/VerifyUserCodeRequest.md
@@ -0,0 +1,56 @@
+# VerifyUserCodeRequest
+
+## Properties
+
+Name | Type | Description | Notes
+------------ | ------------- | ------------- | -------------
+**UserCode** | Pointer to **string** |  | [optional] 
+
+## Methods
+
+### NewVerifyUserCodeRequest
+
+`func NewVerifyUserCodeRequest() *VerifyUserCodeRequest`
+
+NewVerifyUserCodeRequest instantiates a new VerifyUserCodeRequest object
+This constructor will assign default values to properties that have it defined,
+and makes sure properties required by API are set, but the set of arguments
+will change when the set of required properties is changed
+
+### NewVerifyUserCodeRequestWithDefaults
+
+`func NewVerifyUserCodeRequestWithDefaults() *VerifyUserCodeRequest`
+
+NewVerifyUserCodeRequestWithDefaults instantiates a new VerifyUserCodeRequest object
+This constructor will only assign default values to properties that have it defined,
+but it doesn't guarantee that properties required by API are set
+
+### GetUserCode
+
+`func (o *VerifyUserCodeRequest) GetUserCode() string`
+
+GetUserCode returns the UserCode field if non-nil, zero value otherwise.
+
+### GetUserCodeOk
+
+`func (o *VerifyUserCodeRequest) GetUserCodeOk() (*string, bool)`
+
+GetUserCodeOk returns a tuple with the UserCode field if it's non-nil, zero value otherwise
+and a boolean to check if the value has been set.
+
+### SetUserCode
+
+`func (o *VerifyUserCodeRequest) SetUserCode(v string)`
+
+SetUserCode sets UserCode field to given value.
+
+### HasUserCode
+
+`func (o *VerifyUserCodeRequest) HasUserCode() bool`
+
+HasUserCode returns a boolean if a field has been set.
+
+
+[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)
+
+
diff --git a/internal/httpclient/model_device_authorization.go b/internal/httpclient/model_device_authorization.go
new file mode 100644
index 0000000000..8aa32ff623
--- /dev/null
+++ b/internal/httpclient/model_device_authorization.go
@@ -0,0 +1,300 @@
+/*
+Ory Hydra API
+
+Documentation for all of Ory Hydra's APIs.
+
+API version:
+Contact: hi@ory.sh
+*/
+
+// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
+
+package openapi
+
+import (
+	"encoding/json"
+)
+
+// DeviceAuthorization # Ory's OAuth 2.0 Device Authorization API
+type DeviceAuthorization struct {
+	// The device verification code.
+	DeviceCode *string `json:"device_code,omitempty"`
+	// The lifetime in seconds of the \"device_code\" and \"user_code\".
+	ExpiresIn *int64 `json:"expires_in,omitempty"`
+	// The minimum amount of time in seconds that the client SHOULD wait between polling requests to the token endpoint.  If no value is provided, clients MUST use 5 as the default.
+	Interval *int64 `json:"interval,omitempty"`
+	// The end-user verification code.
+	UserCode *string `json:"user_code,omitempty"`
+	// The end-user verification URI on the authorization server.  The URI should be short and easy to remember as end users will be asked to manually type it into their user agent.
+	VerificationUri *string `json:"verification_uri,omitempty"`
+	// A verification URI that includes the \"user_code\" (or other information with the same function as the \"user_code\"), which is designed for non-textual transmission.
+	VerificationUriComplete *string `json:"verification_uri_complete,omitempty"`
+}
+
+// NewDeviceAuthorization instantiates a new DeviceAuthorization object
+// This constructor will assign default values to properties that have it defined,
+// and makes sure properties required by API are set, but the set of arguments
+// will change when the set of required properties is changed
+func NewDeviceAuthorization() *DeviceAuthorization {
+	this := DeviceAuthorization{}
+	return &this
+}
+
+// NewDeviceAuthorizationWithDefaults instantiates a new DeviceAuthorization object
+// This constructor will only assign default values to properties that have it defined,
+// but it doesn't guarantee that properties required by API are set
+func NewDeviceAuthorizationWithDefaults() *DeviceAuthorization {
+	this := DeviceAuthorization{}
+	return &this
+}
+
+// GetDeviceCode returns the DeviceCode field value if set, zero value otherwise.
+func (o *DeviceAuthorization) GetDeviceCode() string {
+	if o == nil || o.DeviceCode == nil {
+		var ret string
+		return ret
+	}
+	return *o.DeviceCode
+}
+
+// GetDeviceCodeOk returns a tuple with the DeviceCode field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *DeviceAuthorization) GetDeviceCodeOk() (*string, bool) {
+	if o == nil || o.DeviceCode == nil {
+		return nil, false
+	}
+	return o.DeviceCode, true
+}
+
+// HasDeviceCode returns a boolean if a field has been set.
+func (o *DeviceAuthorization) HasDeviceCode() bool {
+	if o != nil && o.DeviceCode != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetDeviceCode gets a reference to the given string and assigns it to the DeviceCode field.
+func (o *DeviceAuthorization) SetDeviceCode(v string) {
+	o.DeviceCode = &v
+}
+
+// GetExpiresIn returns the ExpiresIn field value if set, zero value otherwise.
+func (o *DeviceAuthorization) GetExpiresIn() int64 {
+	if o == nil || o.ExpiresIn == nil {
+		var ret int64
+		return ret
+	}
+	return *o.ExpiresIn
+}
+
+// GetExpiresInOk returns a tuple with the ExpiresIn field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *DeviceAuthorization) GetExpiresInOk() (*int64, bool) {
+	if o == nil || o.ExpiresIn == nil {
+		return nil, false
+	}
+	return o.ExpiresIn, true
+}
+
+// HasExpiresIn returns a boolean if a field has been set.
+func (o *DeviceAuthorization) HasExpiresIn() bool {
+	if o != nil && o.ExpiresIn != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetExpiresIn gets a reference to the given int64 and assigns it to the ExpiresIn field.
+func (o *DeviceAuthorization) SetExpiresIn(v int64) {
+	o.ExpiresIn = &v
+}
+
+// GetInterval returns the Interval field value if set, zero value otherwise.
+func (o *DeviceAuthorization) GetInterval() int64 {
+	if o == nil || o.Interval == nil {
+		var ret int64
+		return ret
+	}
+	return *o.Interval
+}
+
+// GetIntervalOk returns a tuple with the Interval field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *DeviceAuthorization) GetIntervalOk() (*int64, bool) {
+	if o == nil || o.Interval == nil {
+		return nil, false
+	}
+	return o.Interval, true
+}
+
+// HasInterval returns a boolean if a field has been set.
+func (o *DeviceAuthorization) HasInterval() bool {
+	if o != nil && o.Interval != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetInterval gets a reference to the given int64 and assigns it to the Interval field.
+func (o *DeviceAuthorization) SetInterval(v int64) {
+	o.Interval = &v
+}
+
+// GetUserCode returns the UserCode field value if set, zero value otherwise.
+func (o *DeviceAuthorization) GetUserCode() string {
+	if o == nil || o.UserCode == nil {
+		var ret string
+		return ret
+	}
+	return *o.UserCode
+}
+
+// GetUserCodeOk returns a tuple with the UserCode field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *DeviceAuthorization) GetUserCodeOk() (*string, bool) {
+	if o == nil || o.UserCode == nil {
+		return nil, false
+	}
+	return o.UserCode, true
+}
+
+// HasUserCode returns a boolean if a field has been set.
+func (o *DeviceAuthorization) HasUserCode() bool {
+	if o != nil && o.UserCode != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetUserCode gets a reference to the given string and assigns it to the UserCode field.
+func (o *DeviceAuthorization) SetUserCode(v string) {
+	o.UserCode = &v
+}
+
+// GetVerificationUri returns the VerificationUri field value if set, zero value otherwise.
+func (o *DeviceAuthorization) GetVerificationUri() string {
+	if o == nil || o.VerificationUri == nil {
+		var ret string
+		return ret
+	}
+	return *o.VerificationUri
+}
+
+// GetVerificationUriOk returns a tuple with the VerificationUri field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *DeviceAuthorization) GetVerificationUriOk() (*string, bool) {
+	if o == nil || o.VerificationUri == nil {
+		return nil, false
+	}
+	return o.VerificationUri, true
+}
+
+// HasVerificationUri returns a boolean if a field has been set.
+func (o *DeviceAuthorization) HasVerificationUri() bool {
+	if o != nil && o.VerificationUri != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetVerificationUri gets a reference to the given string and assigns it to the VerificationUri field.
+func (o *DeviceAuthorization) SetVerificationUri(v string) {
+	o.VerificationUri = &v
+}
+
+// GetVerificationUriComplete returns the VerificationUriComplete field value if set, zero value otherwise.
+func (o *DeviceAuthorization) GetVerificationUriComplete() string {
+	if o == nil || o.VerificationUriComplete == nil {
+		var ret string
+		return ret
+	}
+	return *o.VerificationUriComplete
+}
+
+// GetVerificationUriCompleteOk returns a tuple with the VerificationUriComplete field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *DeviceAuthorization) GetVerificationUriCompleteOk() (*string, bool) {
+	if o == nil || o.VerificationUriComplete == nil {
+		return nil, false
+	}
+	return o.VerificationUriComplete, true
+}
+
+// HasVerificationUriComplete returns a boolean if a field has been set.
+func (o *DeviceAuthorization) HasVerificationUriComplete() bool {
+	if o != nil && o.VerificationUriComplete != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetVerificationUriComplete gets a reference to the given string and assigns it to the VerificationUriComplete field.
+func (o *DeviceAuthorization) SetVerificationUriComplete(v string) {
+	o.VerificationUriComplete = &v
+}
+
+func (o DeviceAuthorization) MarshalJSON() ([]byte, error) {
+	toSerialize := map[string]interface{}{}
+	if o.DeviceCode != nil {
+		toSerialize["device_code"] = o.DeviceCode
+	}
+	if o.ExpiresIn != nil {
+		toSerialize["expires_in"] = o.ExpiresIn
+	}
+	if o.Interval != nil {
+		toSerialize["interval"] = o.Interval
+	}
+	if o.UserCode != nil {
+		toSerialize["user_code"] = o.UserCode
+	}
+	if o.VerificationUri != nil {
+		toSerialize["verification_uri"] = o.VerificationUri
+	}
+	if o.VerificationUriComplete != nil {
+		toSerialize["verification_uri_complete"] = o.VerificationUriComplete
+	}
+	return json.Marshal(toSerialize)
+}
+
+type NullableDeviceAuthorization struct {
+	value *DeviceAuthorization
+	isSet bool
+}
+
+func (v NullableDeviceAuthorization) Get() *DeviceAuthorization {
+	return v.value
+}
+
+func (v *NullableDeviceAuthorization) Set(val *DeviceAuthorization) {
+	v.value = val
+	v.isSet = true
+}
+
+func (v NullableDeviceAuthorization) IsSet() bool {
+	return v.isSet
+}
+
+func (v *NullableDeviceAuthorization) Unset() {
+	v.value = nil
+	v.isSet = false
+}
+
+func NewNullableDeviceAuthorization(val *DeviceAuthorization) *NullableDeviceAuthorization {
+	return &NullableDeviceAuthorization{value: val, isSet: true}
+}
+
+func (v NullableDeviceAuthorization) MarshalJSON() ([]byte, error) {
+	return json.Marshal(v.value)
+}
+
+func (v *NullableDeviceAuthorization) UnmarshalJSON(src []byte) error {
+	v.isSet = true
+	return json.Unmarshal(src, &v.value)
+}
diff --git a/internal/httpclient/model_device_grant_request.go b/internal/httpclient/model_device_grant_request.go
new file mode 100644
index 0000000000..47f06fa000
--- /dev/null
+++ b/internal/httpclient/model_device_grant_request.go
@@ -0,0 +1,269 @@
+/*
+Ory Hydra API
+
+Documentation for all of Ory Hydra's APIs.
+
+API version:
+Contact: hi@ory.sh
+*/
+
+// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
+
+package openapi
+
+import (
+	"encoding/json"
+	"time"
+)
+
+// DeviceGrantRequest struct for DeviceGrantRequest
+type DeviceGrantRequest struct {
+	// ID is the identifier (\"device challenge\") of the device grant request. It is used to identify the session.
+	Challenge string       `json:"challenge"`
+	Client    OAuth2Client `json:"client"`
+	HandledAt *time.Time   `json:"handled_at,omitempty"`
+	// RequestURL is the original Device Grant URL requested.
+	RequestUrl                   *string  `json:"request_url,omitempty"`
+	RequestedAccessTokenAudience []string `json:"requested_access_token_audience"`
+	RequestedScope               []string `json:"requested_scope"`
+}
+
+// NewDeviceGrantRequest instantiates a new DeviceGrantRequest object
+// This constructor will assign default values to properties that have it defined,
+// and makes sure properties required by API are set, but the set of arguments
+// will change when the set of required properties is changed
+func NewDeviceGrantRequest(challenge string, client OAuth2Client, requestedAccessTokenAudience []string, requestedScope []string) *DeviceGrantRequest {
+	this := DeviceGrantRequest{}
+	this.Challenge = challenge
+	this.Client = client
+	this.RequestedAccessTokenAudience = requestedAccessTokenAudience
+	this.RequestedScope = requestedScope
+	return &this
+}
+
+// NewDeviceGrantRequestWithDefaults instantiates a new DeviceGrantRequest object
+// This constructor will only assign default values to properties that have it defined,
+// but it doesn't guarantee that properties required by API are set
+func NewDeviceGrantRequestWithDefaults() *DeviceGrantRequest {
+	this := DeviceGrantRequest{}
+	return &this
+}
+
+// GetChallenge returns the Challenge field value
+func (o *DeviceGrantRequest) GetChallenge() string {
+	if o == nil {
+		var ret string
+		return ret
+	}
+
+	return o.Challenge
+}
+
+// GetChallengeOk returns a tuple with the Challenge field value
+// and a boolean to check if the value has been set.
+func (o *DeviceGrantRequest) GetChallengeOk() (*string, bool) {
+	if o == nil {
+		return nil, false
+	}
+	return &o.Challenge, true
+}
+
+// SetChallenge sets field value
+func (o *DeviceGrantRequest) SetChallenge(v string) {
+	o.Challenge = v
+}
+
+// GetClient returns the Client field value
+func (o *DeviceGrantRequest) GetClient() OAuth2Client {
+	if o == nil {
+		var ret OAuth2Client
+		return ret
+	}
+
+	return o.Client
+}
+
+// GetClientOk returns a tuple with the Client field value
+// and a boolean to check if the value has been set.
+func (o *DeviceGrantRequest) GetClientOk() (*OAuth2Client, bool) {
+	if o == nil {
+		return nil, false
+	}
+	return &o.Client, true
+}
+
+// SetClient sets field value
+func (o *DeviceGrantRequest) SetClient(v OAuth2Client) {
+	o.Client = v
+}
+
+// GetHandledAt returns the HandledAt field value if set, zero value otherwise.
+func (o *DeviceGrantRequest) GetHandledAt() time.Time {
+	if o == nil || o.HandledAt == nil {
+		var ret time.Time
+		return ret
+	}
+	return *o.HandledAt
+}
+
+// GetHandledAtOk returns a tuple with the HandledAt field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *DeviceGrantRequest) GetHandledAtOk() (*time.Time, bool) {
+	if o == nil || o.HandledAt == nil {
+		return nil, false
+	}
+	return o.HandledAt, true
+}
+
+// HasHandledAt returns a boolean if a field has been set.
+func (o *DeviceGrantRequest) HasHandledAt() bool {
+	if o != nil && o.HandledAt != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetHandledAt gets a reference to the given time.Time and assigns it to the HandledAt field.
+func (o *DeviceGrantRequest) SetHandledAt(v time.Time) {
+	o.HandledAt = &v
+}
+
+// GetRequestUrl returns the RequestUrl field value if set, zero value otherwise.
+func (o *DeviceGrantRequest) GetRequestUrl() string {
+	if o == nil || o.RequestUrl == nil {
+		var ret string
+		return ret
+	}
+	return *o.RequestUrl
+}
+
+// GetRequestUrlOk returns a tuple with the RequestUrl field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *DeviceGrantRequest) GetRequestUrlOk() (*string, bool) {
+	if o == nil || o.RequestUrl == nil {
+		return nil, false
+	}
+	return o.RequestUrl, true
+}
+
+// HasRequestUrl returns a boolean if a field has been set.
+func (o *DeviceGrantRequest) HasRequestUrl() bool {
+	if o != nil && o.RequestUrl != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetRequestUrl gets a reference to the given string and assigns it to the RequestUrl field.
+func (o *DeviceGrantRequest) SetRequestUrl(v string) {
+	o.RequestUrl = &v
+}
+
+// GetRequestedAccessTokenAudience returns the RequestedAccessTokenAudience field value
+func (o *DeviceGrantRequest) GetRequestedAccessTokenAudience() []string {
+	if o == nil {
+		var ret []string
+		return ret
+	}
+
+	return o.RequestedAccessTokenAudience
+}
+
+// GetRequestedAccessTokenAudienceOk returns a tuple with the RequestedAccessTokenAudience field value
+// and a boolean to check if the value has been set.
+func (o *DeviceGrantRequest) GetRequestedAccessTokenAudienceOk() ([]string, bool) {
+	if o == nil {
+		return nil, false
+	}
+	return o.RequestedAccessTokenAudience, true
+}
+
+// SetRequestedAccessTokenAudience sets field value
+func (o *DeviceGrantRequest) SetRequestedAccessTokenAudience(v []string) {
+	o.RequestedAccessTokenAudience = v
+}
+
+// GetRequestedScope returns the RequestedScope field value
+func (o *DeviceGrantRequest) GetRequestedScope() []string {
+	if o == nil {
+		var ret []string
+		return ret
+	}
+
+	return o.RequestedScope
+}
+
+// GetRequestedScopeOk returns a tuple with the RequestedScope field value
+// and a boolean to check if the value has been set.
+func (o *DeviceGrantRequest) GetRequestedScopeOk() ([]string, bool) {
+	if o == nil {
+		return nil, false
+	}
+	return o.RequestedScope, true
+}
+
+// SetRequestedScope sets field value
+func (o *DeviceGrantRequest) SetRequestedScope(v []string) {
+	o.RequestedScope = v
+}
+
+func (o DeviceGrantRequest) MarshalJSON() ([]byte, error) {
+	toSerialize := map[string]interface{}{}
+	if true {
+		toSerialize["challenge"] = o.Challenge
+	}
+	if true {
+		toSerialize["client"] = o.Client
+	}
+	if o.HandledAt != nil {
+		toSerialize["handled_at"] = o.HandledAt
+	}
+	if o.RequestUrl != nil {
+		toSerialize["request_url"] = o.RequestUrl
+	}
+	if true {
+		toSerialize["requested_access_token_audience"] = o.RequestedAccessTokenAudience
+	}
+	if true {
+		toSerialize["requested_scope"] = o.RequestedScope
+	}
+	return json.Marshal(toSerialize)
+}
+
+type NullableDeviceGrantRequest struct {
+	value *DeviceGrantRequest
+	isSet bool
+}
+
+func (v NullableDeviceGrantRequest) Get() *DeviceGrantRequest {
+	return v.value
+}
+
+func (v *NullableDeviceGrantRequest) Set(val *DeviceGrantRequest) {
+	v.value = val
+	v.isSet = true
+}
+
+func (v NullableDeviceGrantRequest) IsSet() bool {
+	return v.isSet
+}
+
+func (v *NullableDeviceGrantRequest) Unset() {
+	v.value = nil
+	v.isSet = false
+}
+
+func NewNullableDeviceGrantRequest(val *DeviceGrantRequest) *NullableDeviceGrantRequest {
+	return &NullableDeviceGrantRequest{value: val, isSet: true}
+}
+
+func (v NullableDeviceGrantRequest) MarshalJSON() ([]byte, error) {
+	return json.Marshal(v.value)
+}
+
+func (v *NullableDeviceGrantRequest) UnmarshalJSON(src []byte) error {
+	v.isSet = true
+	return json.Unmarshal(src, &v.value)
+}
diff --git a/internal/httpclient/model_oidc_configuration.go b/internal/httpclient/model_oidc_configuration.go
index 78411e52b7..6fde8ec493 100644
--- a/internal/httpclient/model_oidc_configuration.go
+++ b/internal/httpclient/model_oidc_configuration.go
@@ -29,6 +29,8 @@ type OidcConfiguration struct {
 	ClaimsSupported []string `json:"claims_supported,omitempty"`
 	// OAuth 2.0 PKCE Supported Code Challenge Methods  JSON array containing a list of Proof Key for Code Exchange (PKCE) [RFC7636] code challenge methods supported by this authorization server.
 	CodeChallengeMethodsSupported []string `json:"code_challenge_methods_supported,omitempty"`
+	// URL of the authorization server's device authorization endpoint
+	DeviceAuthorizationEndpoint *string `json:"device_authorization_endpoint,omitempty"`
 	// OpenID Connect End-Session Endpoint  URL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP.
 	EndSessionEndpoint *string `json:"end_session_endpoint,omitempty"`
 	// OpenID Connect Front-Channel Logout Session Required  Boolean value specifying whether the OP can pass iss (issuer) and sid (session ID) query parameters to identify the RP session with the OP when the frontchannel_logout_uri is used. If supported, the sid Claim is also included in ID Tokens issued by the OP.
@@ -287,6 +289,38 @@ func (o *OidcConfiguration) SetCodeChallengeMethodsSupported(v []string) {
 	o.CodeChallengeMethodsSupported = v
 }
 
+// GetDeviceAuthorizationEndpoint returns the DeviceAuthorizationEndpoint field value if set, zero value otherwise.
+func (o *OidcConfiguration) GetDeviceAuthorizationEndpoint() string {
+	if o == nil || o.DeviceAuthorizationEndpoint == nil {
+		var ret string
+		return ret
+	}
+	return *o.DeviceAuthorizationEndpoint
+}
+
+// GetDeviceAuthorizationEndpointOk returns a tuple with the DeviceAuthorizationEndpoint field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *OidcConfiguration) GetDeviceAuthorizationEndpointOk() (*string, bool) {
+	if o == nil || o.DeviceAuthorizationEndpoint == nil {
+		return nil, false
+	}
+	return o.DeviceAuthorizationEndpoint, true
+}
+
+// HasDeviceAuthorizationEndpoint returns a boolean if a field has been set.
+func (o *OidcConfiguration) HasDeviceAuthorizationEndpoint() bool {
+	if o != nil && o.DeviceAuthorizationEndpoint != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetDeviceAuthorizationEndpoint gets a reference to the given string and assigns it to the DeviceAuthorizationEndpoint field.
+func (o *OidcConfiguration) SetDeviceAuthorizationEndpoint(v string) {
+	o.DeviceAuthorizationEndpoint = &v
+}
+
 // GetEndSessionEndpoint returns the EndSessionEndpoint field value if set, zero value otherwise.
 func (o *OidcConfiguration) GetEndSessionEndpoint() string {
 	if o == nil || o.EndSessionEndpoint == nil {
@@ -979,6 +1013,9 @@ func (o OidcConfiguration) MarshalJSON() ([]byte, error) {
 	if o.CodeChallengeMethodsSupported != nil {
 		toSerialize["code_challenge_methods_supported"] = o.CodeChallengeMethodsSupported
 	}
+	if o.DeviceAuthorizationEndpoint != nil {
+		toSerialize["device_authorization_endpoint"] = o.DeviceAuthorizationEndpoint
+	}
 	if o.EndSessionEndpoint != nil {
 		toSerialize["end_session_endpoint"] = o.EndSessionEndpoint
 	}
diff --git a/internal/httpclient/model_verify_user_code_request.go b/internal/httpclient/model_verify_user_code_request.go
new file mode 100644
index 0000000000..514847a308
--- /dev/null
+++ b/internal/httpclient/model_verify_user_code_request.go
@@ -0,0 +1,114 @@
+/*
+Ory Hydra API
+
+Documentation for all of Ory Hydra's APIs.
+
+API version:
+Contact: hi@ory.sh
+*/
+
+// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
+
+package openapi
+
+import (
+	"encoding/json"
+)
+
+// VerifyUserCodeRequest Contains information on an device verification
+type VerifyUserCodeRequest struct {
+	UserCode *string `json:"user_code,omitempty"`
+}
+
+// NewVerifyUserCodeRequest instantiates a new VerifyUserCodeRequest object
+// This constructor will assign default values to properties that have it defined,
+// and makes sure properties required by API are set, but the set of arguments
+// will change when the set of required properties is changed
+func NewVerifyUserCodeRequest() *VerifyUserCodeRequest {
+	this := VerifyUserCodeRequest{}
+	return &this
+}
+
+// NewVerifyUserCodeRequestWithDefaults instantiates a new VerifyUserCodeRequest object
+// This constructor will only assign default values to properties that have it defined,
+// but it doesn't guarantee that properties required by API are set
+func NewVerifyUserCodeRequestWithDefaults() *VerifyUserCodeRequest {
+	this := VerifyUserCodeRequest{}
+	return &this
+}
+
+// GetUserCode returns the UserCode field value if set, zero value otherwise.
+func (o *VerifyUserCodeRequest) GetUserCode() string {
+	if o == nil || o.UserCode == nil {
+		var ret string
+		return ret
+	}
+	return *o.UserCode
+}
+
+// GetUserCodeOk returns a tuple with the UserCode field value if set, nil otherwise
+// and a boolean to check if the value has been set.
+func (o *VerifyUserCodeRequest) GetUserCodeOk() (*string, bool) {
+	if o == nil || o.UserCode == nil {
+		return nil, false
+	}
+	return o.UserCode, true
+}
+
+// HasUserCode returns a boolean if a field has been set.
+func (o *VerifyUserCodeRequest) HasUserCode() bool {
+	if o != nil && o.UserCode != nil {
+		return true
+	}
+
+	return false
+}
+
+// SetUserCode gets a reference to the given string and assigns it to the UserCode field.
+func (o *VerifyUserCodeRequest) SetUserCode(v string) {
+	o.UserCode = &v
+}
+
+func (o VerifyUserCodeRequest) MarshalJSON() ([]byte, error) {
+	toSerialize := map[string]interface{}{}
+	if o.UserCode != nil {
+		toSerialize["user_code"] = o.UserCode
+	}
+	return json.Marshal(toSerialize)
+}
+
+type NullableVerifyUserCodeRequest struct {
+	value *VerifyUserCodeRequest
+	isSet bool
+}
+
+func (v NullableVerifyUserCodeRequest) Get() *VerifyUserCodeRequest {
+	return v.value
+}
+
+func (v *NullableVerifyUserCodeRequest) Set(val *VerifyUserCodeRequest) {
+	v.value = val
+	v.isSet = true
+}
+
+func (v NullableVerifyUserCodeRequest) IsSet() bool {
+	return v.isSet
+}
+
+func (v *NullableVerifyUserCodeRequest) Unset() {
+	v.value = nil
+	v.isSet = false
+}
+
+func NewNullableVerifyUserCodeRequest(val *VerifyUserCodeRequest) *NullableVerifyUserCodeRequest {
+	return &NullableVerifyUserCodeRequest{value: val, isSet: true}
+}
+
+func (v NullableVerifyUserCodeRequest) MarshalJSON() ([]byte, error) {
+	return json.Marshal(v.value)
+}
+
+func (v *NullableVerifyUserCodeRequest) UnmarshalJSON(src []byte) error {
+	v.isSet = true
+	return json.Unmarshal(src, &v.value)
+}
diff --git a/oauth2/.snapshots/TestHandlerWellKnown-hsm_enabled=false.json b/oauth2/.snapshots/TestHandlerWellKnown-hsm_enabled=false.json
index 330e25c43a..3824cfc871 100644
--- a/oauth2/.snapshots/TestHandlerWellKnown-hsm_enabled=false.json
+++ b/oauth2/.snapshots/TestHandlerWellKnown-hsm_enabled=false.json
@@ -10,6 +10,7 @@
     "plain",
     "S256"
   ],
+  "device_authorization_endpoint": "http://hydra.localhost/oauth2/device/auth",
   "end_session_endpoint": "http://hydra.localhost/oauth2/sessions/logout",
   "frontchannel_logout_session_supported": true,
   "frontchannel_logout_supported": true,
@@ -17,7 +18,8 @@
     "authorization_code",
     "implicit",
     "client_credentials",
-    "refresh_token"
+    "refresh_token",
+    "urn:ietf:params:oauth:grant-type:device_code"
   ],
   "id_token_signed_response_alg": [
     "RS256"
diff --git a/oauth2/.snapshots/TestHandlerWellKnown-hsm_enabled=true.json b/oauth2/.snapshots/TestHandlerWellKnown-hsm_enabled=true.json
index 330e25c43a..3824cfc871 100644
--- a/oauth2/.snapshots/TestHandlerWellKnown-hsm_enabled=true.json
+++ b/oauth2/.snapshots/TestHandlerWellKnown-hsm_enabled=true.json
@@ -10,6 +10,7 @@
     "plain",
     "S256"
   ],
+  "device_authorization_endpoint": "http://hydra.localhost/oauth2/device/auth",
   "end_session_endpoint": "http://hydra.localhost/oauth2/sessions/logout",
   "frontchannel_logout_session_supported": true,
   "frontchannel_logout_supported": true,
@@ -17,7 +18,8 @@
     "authorization_code",
     "implicit",
     "client_credentials",
-    "refresh_token"
+    "refresh_token",
+    "urn:ietf:params:oauth:grant-type:device_code"
   ],
   "id_token_signed_response_alg": [
     "RS256"
diff --git a/oauth2/handler.go b/oauth2/handler.go
index c9eaaaa0c6..79e2e573a8 100644
--- a/oauth2/handler.go
+++ b/oauth2/handler.go
@@ -37,6 +37,8 @@ const (
 	DefaultConsentPath    = "/oauth2/fallbacks/consent"
 	DefaultPostLogoutPath = "/oauth2/fallbacks/logout/callback"
 	DefaultLogoutPath     = "/oauth2/fallbacks/logout"
+	DefaultDevicePath     = "/oauth2/fallbacks/device"
+	DefaultPostDevicePath = "/oauth2/fallbacks/device/done"
 	DefaultErrorPath      = "/oauth2/fallbacks/error"
 	TokenPath             = "/oauth2/token" // #nosec G101
 	AuthPath              = "/oauth2/auth"
@@ -50,6 +52,9 @@ const (
 	IntrospectPath   = "/oauth2/introspect"
 	RevocationPath   = "/oauth2/revoke"
 	DeleteTokensPath = "/oauth2/tokens" // #nosec G101
+
+	// Device Grant Handler
+	DeviceAuthPath = "/oauth2/device/auth"
 )
 
 type Handler struct {
@@ -73,6 +78,13 @@ func (h *Handler) SetRoutes(admin *httprouterx.RouterAdmin, public *httprouterx.
 	public.GET(DefaultLoginPath, h.fallbackHandler("", "", http.StatusOK, config.KeyLoginURL))
 	public.GET(DefaultConsentPath, h.fallbackHandler("", "", http.StatusOK, config.KeyConsentURL))
 	public.GET(DefaultLogoutPath, h.fallbackHandler("", "", http.StatusOK, config.KeyLogoutURL))
+	public.GET(DefaultDevicePath, h.fallbackHandler("", "", http.StatusOK, config.KeyDeviceURL))
+	public.GET(DefaultPostDevicePath, h.fallbackHandler(
+		"You successfully authenticated on your device!",
+		"The Default Post Device URL is not set which is why you are seeing this fallback page. Your device login request however succeeded.",
+		http.StatusOK,
+		config.KeyDeviceDoneURL,
+	))
 	public.GET(DefaultPostLogoutPath, h.fallbackHandler(
 		"You logged out successfully!",
 		"The Default Post Logout URL is not set which is why you are seeing this fallback page. Your log out request however succeeded.",
@@ -91,6 +103,208 @@ func (h *Handler) SetRoutes(admin *httprouterx.RouterAdmin, public *httprouterx.
 
 	admin.POST(IntrospectPath, h.introspectOAuth2Token)
 	admin.DELETE(DeleteTokensPath, h.deleteOAuth2Token)
+
+	public.GET(DeviceAuthPath, h.performOAuth2DeviceAuthorizationFlow)
+	// This endpoint should be call on the device side
+	public.POST(DeviceAuthPath, h.performOAuth2DeviceFlow)
+}
+
+// FIXME: Add Doc
+func (h *Handler) performOAuth2DeviceAuthorizationFlow(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
+	var ctx = r.Context()
+
+	authorizeRequest, err := h.r.OAuth2Provider().NewDeviceAuthorizeRequest(ctx, r)
+	if err != nil {
+		x.LogError(r, err, h.r.Logger())
+		return
+	}
+
+	session, err := h.r.ConsentStrategy().HandleOAuth2DeviceAuthorizationRequest(ctx, w, r, authorizeRequest)
+	if errors.Is(err, consent.ErrAbortOAuth2Request) {
+		x.LogAudit(r, nil, h.r.AuditLogger())
+		// do nothing
+		return
+	} else if e := &(fosite.RFC6749Error{}); errors.As(err, &e) {
+		x.LogAudit(r, err, h.r.AuditLogger())
+		h.r.Writer().WriteError(w, r, err)
+		return
+	} else if err != nil {
+		x.LogError(r, err, h.r.Logger())
+		h.r.Writer().WriteError(w, r, err)
+		return
+	}
+
+	authorizeRequest.SetRequestedScopes(fosite.Arguments(session.ConsentRequest.RequestedScope))
+	for _, scope := range session.GrantedScope {
+		authorizeRequest.GrantScope(scope)
+	}
+
+	authorizeRequest.SetRequestedAudience(fosite.Arguments(session.ConsentRequest.RequestedAudience))
+	for _, audience := range session.GrantedAudience {
+		authorizeRequest.GrantAudience(audience)
+	}
+
+	openIDKeyID, err := h.r.OpenIDJWTStrategy().GetPublicKeyID(ctx)
+	if err != nil {
+		x.LogError(r, err, h.r.Logger())
+		h.r.Writer().WriteError(w, r, err)
+		return
+	}
+
+	var accessTokenKeyID string
+	if h.c.AccessTokenStrategy(r.Context()) == "jwt" {
+		accessTokenKeyID, err = h.r.AccessTokenJWTStrategy().GetPublicKeyID(ctx)
+		if err != nil {
+			x.LogError(r, err, h.r.Logger())
+			h.r.Writer().WriteError(w, r, err)
+			return
+		}
+	}
+
+	obfuscatedSubject, err := h.r.ConsentStrategy().ObfuscateSubjectIdentifier(ctx, authorizeRequest.GetClient(), session.ConsentRequest.Subject, session.ConsentRequest.ForceSubjectIdentifier)
+	if e := &(fosite.RFC6749Error{}); errors.As(err, &e) {
+		x.LogAudit(r, err, h.r.AuditLogger())
+		h.r.Writer().WriteError(w, r, err)
+		return
+	} else if err != nil {
+		x.LogError(r, err, h.r.Logger())
+		h.r.Writer().WriteError(w, r, err)
+		return
+	}
+
+	authorizeRequest.SetID(session.ID)
+	claims := &jwt.IDTokenClaims{
+		Subject:                             obfuscatedSubject,
+		Issuer:                              h.c.IssuerURL(ctx).String(),
+		AuthTime:                            time.Time(session.AuthenticatedAt),
+		RequestedAt:                         session.RequestedAt,
+		Extra:                               session.Session.IDToken,
+		AuthenticationContextClassReference: session.ConsentRequest.ACR,
+		AuthenticationMethodsReferences:     session.ConsentRequest.AMR,
+
+		// These are required for work around https://github.com/ory/fosite/issues/530
+		Nonce:    authorizeRequest.GetRequestForm().Get("nonce"),
+		Audience: []string{authorizeRequest.GetClient().GetID()},
+		IssuedAt: time.Now().Truncate(time.Second).UTC(),
+
+		// This is set by the fosite strategy
+		// ExpiresAt:   time.Now().Add(h.IDTokenLifespan).UTC(),
+	}
+	claims.Add("sid", session.ConsentRequest.LoginSessionID)
+
+	// done
+	response, err := h.r.OAuth2Provider().NewDeviceAuthorizeResponse(ctx, authorizeRequest, &Session{
+		DefaultSession: &openid.DefaultSession{
+			Claims: claims,
+			Headers: &jwt.Headers{Extra: map[string]interface{}{
+				// required for lookup on jwk endpoint
+				"kid": openIDKeyID,
+			}},
+			Subject: session.ConsentRequest.Subject,
+		},
+		Extra:                 session.Session.AccessToken,
+		KID:                   accessTokenKeyID,
+		ClientID:              authorizeRequest.GetClient().GetID(),
+		ConsentChallenge:      session.ID,
+		ExcludeNotBeforeClaim: h.c.ExcludeNotBeforeClaim(ctx),
+		AllowedTopLevelClaims: h.c.AllowedTopLevelClaims(ctx),
+	})
+	if err != nil {
+		x.LogError(r, err, h.r.Logger())
+		h.r.Writer().WriteError(w, r, err)
+		return
+	}
+
+	err = h.r.OAuth2Storage().UpdateDeviceCodeSession(ctx, authorizeRequest.GetDeviceCodeSignature(), authorizeRequest)
+	if err != nil {
+		x.LogError(r, err, h.r.Logger())
+		h.r.Writer().WriteError(w, r, err)
+	}
+
+	h.r.OAuth2Provider().WriteDeviceAuthorizeResponse(ctx, r, w, authorizeRequest, response)
+}
+
+// OAuth2 Device Flow
+//
+// # Ory's OAuth 2.0 Device Authorization API
+//
+// swagger:model deviceAuthorization
+type deviceAuthorization struct {
+	// The device verification code.
+	//
+	// example: ory_dc_smldfksmdfkl.mslkmlkmlk
+	DeviceCode string `json:"device_code"`
+
+	// The end-user verification code.
+	//
+	// example: AAAAAA
+	UserCode string `json:"user_code"`
+
+	// The end-user verification URI on the authorization
+	// server.  The URI should be short and easy to remember as end users
+	// will be asked to manually type it into their user agent.
+	//
+	// example: https://auth.ory.sh/tv
+	VerificationUri string `json:"verification_uri"`
+
+	// A verification URI that includes the "user_code" (or
+	// other information with the same function as the "user_code"),
+	// which is designed for non-textual transmission.
+	//
+	// example: https://auth.ory.sh/tv?user_code=AAAAAA
+	VerificationUriComplete string `json:"verification_uri_complete"`
+
+	// The lifetime in seconds of the "device_code" and "user_code".
+	//
+	// example: 16830
+	ExpiresIn int `json:"expires_in"`
+
+	// The minimum amount of time in seconds that the client
+	// SHOULD wait between polling requests to the token endpoint.  If no
+	// value is provided, clients MUST use 5 as the default.
+	//
+	// example: 5
+	Interval int `json:"interval"`
+}
+
+// swagger:route GET /oauth2/device/auth v0alpha2 performOAuth2DeviceFlow
+//
+// # The OAuth 2.0 Device Authorize Endpoint
+//
+// This endpoint is not documented here because you should never use your own implementation to perform OAuth2 flows.
+// OAuth2 is a very popular protocol and a library for your programming language will exists.
+//
+// To learn more about this flow please refer to the specification: https://tools.ietf.org/html/rfc8628
+//
+//	Consumes:
+//	- application/x-www-form-urlencoded
+//
+//	Schemes: http, https
+//
+//	Responses:
+//	  200: deviceAuthorization
+//	  default: errorOAuth2
+func (h *Handler) performOAuth2DeviceFlow(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
+	var ctx = r.Context()
+	request, err := h.r.OAuth2Provider().NewDeviceRequest(ctx, r)
+	if err != nil {
+		h.r.Writer().WriteError(w, r, err)
+		return
+	}
+
+	var session = &Session{
+		DefaultSession: &openid.DefaultSession{
+			Headers: &jwt.Headers{}},
+	}
+
+	request.SetSession(session)
+	resp, err := h.r.OAuth2Provider().NewDeviceResponse(ctx, request)
+	if err != nil {
+		h.r.Writer().WriteError(w, r, err)
+		return
+	}
+
+	h.r.OAuth2Provider().WriteDeviceResponse(ctx, w, request, resp)
 }
 
 // swagger:route GET /oauth2/sessions/logout oidc revokeOidcSession
@@ -240,6 +454,9 @@ type oidcConfiguration struct {
 	// example: https://playground.ory.sh/ory-hydra/public/oauth2/token
 	TokenURL string `json:"token_endpoint"`
 
+	// URL of the authorization server's device authorization endpoint
+	DeviceAuthorisationEndpoint string `json:"device_authorization_endpoint"`
+
 	// OpenID Connect Well-Known JSON Web Keys URL
 	//
 	// URL of the OP's JSON Web Key Set [JWK] document. This contains the signing key(s) the RP uses to validate
@@ -432,6 +649,7 @@ func (h *Handler) discoverOidcConfiguration(w http.ResponseWriter, r *http.Reque
 		JWKsURI:                                h.c.JWKSURL(r.Context()).String(),
 		RevocationEndpoint:                     urlx.AppendPaths(h.c.IssuerURL(r.Context()), RevocationPath).String(),
 		RegistrationEndpoint:                   h.c.OAuth2ClientRegistrationURL(r.Context()).String(),
+		DeviceAuthorisationEndpoint:            h.c.OAuth2DeviceAuthorisationURL(r.Context()).String(),
 		SubjectTypes:                           h.c.SubjectTypesSupported(r.Context()),
 		ResponseTypes:                          []string{"code", "code id_token", "id_token", "token id_token", "token", "token id_token code"},
 		ClaimsSupported:                        h.c.OIDCDiscoverySupportedClaims(r.Context()),
@@ -441,7 +659,7 @@ func (h *Handler) discoverOidcConfiguration(w http.ResponseWriter, r *http.Reque
 		IDTokenSigningAlgValuesSupported:       []string{key.Algorithm},
 		IDTokenSignedResponseAlg:               []string{key.Algorithm},
 		UserinfoSignedResponseAlg:              []string{key.Algorithm},
-		GrantTypesSupported:                    []string{"authorization_code", "implicit", "client_credentials", "refresh_token"},
+		GrantTypesSupported:                    []string{"authorization_code", "implicit", "client_credentials", "refresh_token", "urn:ietf:params:oauth:grant-type:device_code"},
 		ResponseModesSupported:                 []string{"query", "fragment"},
 		UserinfoSigningAlgValuesSupported:      []string{"none", key.Algorithm},
 		RequestParameterSupported:              true,
diff --git a/oauth2/oauth2_helper_test.go b/oauth2/oauth2_helper_test.go
index ea679c2418..542485c0c1 100644
--- a/oauth2/oauth2_helper_test.go
+++ b/oauth2/oauth2_helper_test.go
@@ -53,6 +53,26 @@ func (c *consentMock) HandleHeadlessLogout(ctx context.Context, w http.ResponseW
 	panic("not implemented")
 }
 
+func (c *consentMock) HandleOAuth2DeviceAuthorizationRequest(ctx context.Context, w http.ResponseWriter, r *http.Request, req fosite.DeviceAuthorizeRequester) (*consent.AcceptOAuth2ConsentRequest, error) {
+	if c.deny {
+		return nil, fosite.ErrRequestForbidden
+	}
+
+	return &consent.AcceptOAuth2ConsentRequest{
+		ConsentRequest: &consent.OAuth2ConsentRequest{
+			Subject: "foo",
+			ACR:     "1",
+		},
+		AuthenticatedAt: sqlxx.NullTime(c.authTime),
+		GrantedScope:    []string{"offline", "openid", "hydra.*"},
+		Session: &consent.AcceptOAuth2ConsentRequestSession{
+			AccessToken: map[string]interface{}{},
+			IDToken:     map[string]interface{}{},
+		},
+		RequestedAt: c.requestTime,
+	}, nil
+}
+
 func (c *consentMock) ObfuscateSubjectIdentifier(ctx context.Context, cl fosite.Client, subject, forcedIdentifier string) (string, error) {
 	if c, ok := cl.(*client.Client); ok && c.SubjectType == "pairwise" {
 		panic("not implemented")
diff --git a/oauth2/oauth2_provider_mock_test.go b/oauth2/oauth2_provider_mock_test.go
index 83d584eb12..a5042643a6 100644
--- a/oauth2/oauth2_provider_mock_test.go
+++ b/oauth2/oauth2_provider_mock_test.go
@@ -121,6 +121,66 @@ func (mr *MockOAuth2ProviderMockRecorder) NewAuthorizeResponse(arg0, arg1, arg2
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewAuthorizeResponse", reflect.TypeOf((*MockOAuth2Provider)(nil).NewAuthorizeResponse), arg0, arg1, arg2)
 }
 
+// NewDeviceAuthorizeRequest mocks base method.
+func (m *MockOAuth2Provider) NewDeviceAuthorizeRequest(arg0 context.Context, arg1 *http.Request) (fosite.DeviceAuthorizeRequester, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "NewDeviceAuthorizeRequest", arg0, arg1)
+	ret0, _ := ret[0].(fosite.DeviceAuthorizeRequester)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// NewDeviceAuthorizeRequest indicates an expected call of NewDeviceAuthorizeRequest.
+func (mr *MockOAuth2ProviderMockRecorder) NewDeviceAuthorizeRequest(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewDeviceAuthorizeRequest", reflect.TypeOf((*MockOAuth2Provider)(nil).NewDeviceAuthorizeRequest), arg0, arg1)
+}
+
+// NewDeviceAuthorizeResponse mocks base method.
+func (m *MockOAuth2Provider) NewDeviceAuthorizeResponse(arg0 context.Context, arg1 fosite.DeviceAuthorizeRequester, arg2 fosite.Session) (fosite.DeviceAuthorizeResponder, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "NewDeviceAuthorizeResponse", arg0, arg1, arg2)
+	ret0, _ := ret[0].(fosite.DeviceAuthorizeResponder)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// NewDeviceAuthorizeResponse indicates an expected call of NewDeviceAuthorizeResponse.
+func (mr *MockOAuth2ProviderMockRecorder) NewDeviceAuthorizeResponse(arg0, arg1, arg2 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewDeviceAuthorizeResponse", reflect.TypeOf((*MockOAuth2Provider)(nil).NewDeviceAuthorizeResponse), arg0, arg1, arg2)
+}
+
+// NewDeviceRequest mocks base method.
+func (m *MockOAuth2Provider) NewDeviceRequest(arg0 context.Context, arg1 *http.Request) (fosite.DeviceRequester, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "NewDeviceRequest", arg0, arg1)
+	ret0, _ := ret[0].(fosite.DeviceRequester)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// NewDeviceRequest indicates an expected call of NewDeviceRequest.
+func (mr *MockOAuth2ProviderMockRecorder) NewDeviceRequest(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewDeviceRequest", reflect.TypeOf((*MockOAuth2Provider)(nil).NewDeviceRequest), arg0, arg1)
+}
+
+// NewDeviceResponse mocks base method.
+func (m *MockOAuth2Provider) NewDeviceResponse(arg0 context.Context, arg1 fosite.DeviceRequester) (fosite.DeviceResponder, error) {
+	m.ctrl.T.Helper()
+	ret := m.ctrl.Call(m, "NewDeviceResponse", arg0, arg1)
+	ret0, _ := ret[0].(fosite.DeviceResponder)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
+}
+
+// NewDeviceResponse indicates an expected call of NewDeviceResponse.
+func (mr *MockOAuth2ProviderMockRecorder) NewDeviceResponse(arg0, arg1 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewDeviceResponse", reflect.TypeOf((*MockOAuth2Provider)(nil).NewDeviceResponse), arg0, arg1)
+}
+
 // NewIntrospectionRequest mocks base method.
 func (m *MockOAuth2Provider) NewIntrospectionRequest(arg0 context.Context, arg1 *http.Request, arg2 fosite.Session) (fosite.IntrospectionResponder, error) {
 	m.ctrl.T.Helper()
@@ -228,6 +288,30 @@ func (mr *MockOAuth2ProviderMockRecorder) WriteAuthorizeResponse(arg0, arg1, arg
 	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteAuthorizeResponse", reflect.TypeOf((*MockOAuth2Provider)(nil).WriteAuthorizeResponse), arg0, arg1, arg2, arg3)
 }
 
+// WriteDeviceAuthorizeResponse mocks base method.
+func (m *MockOAuth2Provider) WriteDeviceAuthorizeResponse(arg0 context.Context, arg1 *http.Request, arg2 http.ResponseWriter, arg3 fosite.DeviceAuthorizeRequester, arg4 fosite.DeviceAuthorizeResponder) {
+	m.ctrl.T.Helper()
+	m.ctrl.Call(m, "WriteDeviceAuthorizeResponse", arg0, arg1, arg2, arg3, arg4)
+}
+
+// WriteDeviceAuthorizeResponse indicates an expected call of WriteDeviceAuthorizeResponse.
+func (mr *MockOAuth2ProviderMockRecorder) WriteDeviceAuthorizeResponse(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteDeviceAuthorizeResponse", reflect.TypeOf((*MockOAuth2Provider)(nil).WriteDeviceAuthorizeResponse), arg0, arg1, arg2, arg3, arg4)
+}
+
+// WriteDeviceResponse mocks base method.
+func (m *MockOAuth2Provider) WriteDeviceResponse(arg0 context.Context, arg1 http.ResponseWriter, arg2 fosite.DeviceRequester, arg3 fosite.DeviceResponder) {
+	m.ctrl.T.Helper()
+	m.ctrl.Call(m, "WriteDeviceResponse", arg0, arg1, arg2, arg3)
+}
+
+// WriteDeviceResponse indicates an expected call of WriteDeviceResponse.
+func (mr *MockOAuth2ProviderMockRecorder) WriteDeviceResponse(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
+	mr.mock.ctrl.T.Helper()
+	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteDeviceResponse", reflect.TypeOf((*MockOAuth2Provider)(nil).WriteDeviceResponse), arg0, arg1, arg2, arg3)
+}
+
 // WriteIntrospectionError mocks base method.
 func (m *MockOAuth2Provider) WriteIntrospectionError(arg0 context.Context, arg1 http.ResponseWriter, arg2 error) {
 	m.ctrl.T.Helper()
diff --git a/persistence/sql/migrations/20220823111500000000_support_device_grants.cockroach.up.sql b/persistence/sql/migrations/20220823111500000000_support_device_grants.cockroach.up.sql
new file mode 100644
index 0000000000..172adae0e7
--- /dev/null
+++ b/persistence/sql/migrations/20220823111500000000_support_device_grants.cockroach.up.sql
@@ -0,0 +1,47 @@
+CREATE TABLE IF NOT EXISTS hydra_oauth2_device_code 
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(255)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT NOW(),
+    client_id          VARCHAR(255) NOT NULL,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             BOOL         NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL DEFAULT '',
+    granted_audience   TEXT         NULL DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL,
+    nid                UUID         NULL
+);
+CREATE INDEX hydra_oauth2_device_code_request_id_idx ON hydra_oauth2_device_code (request_id, nid);
+CREATE INDEX hydra_oauth2_device_code_client_id_idx ON hydra_oauth2_device_code (client_id, nid);
+CREATE INDEX hydra_oauth2_device_code_challenge_id_idx ON hydra_oauth2_device_code (challenge_id, nid);
+ALTER TABLE hydra_oauth2_device_code ADD CONSTRAINT hydra_oauth2_device_code_challenge_id_fk FOREIGN KEY (challenge_id) REFERENCES hydra_oauth2_flow(consent_challenge_id) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_device_code ADD CONSTRAINT hydra_oauth2_device_code_client_id_fk FOREIGN KEY (client_id, nid) REFERENCES hydra_client(id, nid) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_device_code ADD CONSTRAINT hydra_oauth2_device_code_nid_fk_idx FOREIGN KEY (nid) REFERENCES networks(id) ON UPDATE RESTRICT ON DELETE CASCADE;
+
+CREATE TABLE IF NOT EXISTS hydra_oauth2_user_code 
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(40)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT NOW(),
+    client_id          VARCHAR(255) NOT NULL,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             BOOL         NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL DEFAULT '',
+    granted_audience   TEXT         NULL DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL,
+    nid                UUID         NULL
+);
+CREATE INDEX hydra_oauth2_user_code_request_id_idx ON hydra_oauth2_user_code (request_id, nid);
+CREATE INDEX hydra_oauth2_user_code_client_id_idx ON hydra_oauth2_user_code (client_id, nid);
+CREATE INDEX hydra_oauth2_user_code_challenge_id_idx ON hydra_oauth2_user_code (challenge_id, nid);
+ALTER TABLE hydra_oauth2_user_code ADD CONSTRAINT hydra_oauth2_user_code_challenge_id_fk FOREIGN KEY (challenge_id) REFERENCES hydra_oauth2_flow(consent_challenge_id) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_user_code ADD CONSTRAINT hydra_oauth2_user_code_client_id_fk FOREIGN KEY (client_id, nid) REFERENCES hydra_client(id, nid) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_user_code ADD CONSTRAINT hydra_oauth2_user_code_nid_fk_idx FOREIGN KEY (nid) REFERENCES networks(id) ON UPDATE RESTRICT ON DELETE CASCADE;
diff --git a/persistence/sql/migrations/20220823111500000000_support_device_grants.down.sql b/persistence/sql/migrations/20220823111500000000_support_device_grants.down.sql
new file mode 100644
index 0000000000..c331749dac
--- /dev/null
+++ b/persistence/sql/migrations/20220823111500000000_support_device_grants.down.sql
@@ -0,0 +1,21 @@
+ALTER TABLE
+    hydra_oauth2_device_code DROP FOREIGN KEY IF EXISTS hydra_oauth2_device_code_challenge_id_fk;
+
+ALTER TABLE
+    hydra_oauth2_device_code DROP FOREIGN KEY IF EXISTS hydra_oauth2_device_code_client_id_fk;
+
+ALTER TABLE
+    hydra_oauth2_device_code DROP FOREIGN KEY IF EXISTS hydra_oauth2_device_code_nid_fk_idx;
+
+DROP TABLE IF EXISTS hydra_oauth2_device_code;
+
+ALTER TABLE
+    hydra_oauth2_user_code DROP FOREIGN KEY IF EXISTS hydra_oauth2_user_code_challenge_id_fk;
+
+ALTER TABLE
+    hydra_oauth2_user_code DROP FOREIGN KEY IF EXISTS hydra_oauth2_user_code_client_id_fk;
+
+ALTER TABLE
+    hydra_oauth2_user_code DROP FOREIGN KEY IF EXISTS hydra_oauth2_user_code_nid_fk_idx;
+
+DROP TABLE IF EXISTS hydra_oauth2_user_code;
\ No newline at end of file
diff --git a/persistence/sql/migrations/20220823111500000000_support_device_grants.mysql.up.sql b/persistence/sql/migrations/20220823111500000000_support_device_grants.mysql.up.sql
new file mode 100644
index 0000000000..2212460c78
--- /dev/null
+++ b/persistence/sql/migrations/20220823111500000000_support_device_grants.mysql.up.sql
@@ -0,0 +1,49 @@
+CREATE TABLE IF NOT EXISTS hydra_oauth2_device_code 
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(255) NOT NULL DEFAULT '',
+    requested_at       TIMESTAMP    NOT NULL DEFAULT NOW(),
+    client_id          VARCHAR(255) NOT NULL DEFAULT '',
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             BOOL         NOT NULL DEFAULT true,
+    requested_audience TEXT         NOT NULL,
+    granted_audience   TEXT         NOT NULL,
+    challenge_id       VARCHAR(40)  NULL,
+    nid                CHAR(36)     NOT NULL
+);
+CREATE INDEX hydra_oauth2_device_code_nid_fk_idx ON hydra_oauth2_device_code (nid);
+CREATE INDEX hydra_oauth2_device_code_request_id_idx ON hydra_oauth2_device_code (request_id, nid);
+CREATE INDEX hydra_oauth2_device_code_client_id_idx ON hydra_oauth2_device_code (client_id, nid);
+CREATE INDEX hydra_oauth2_device_code_challenge_id_idx ON hydra_oauth2_device_code (challenge_id);
+ALTER TABLE hydra_oauth2_device_code ADD CONSTRAINT hydra_oauth2_device_code_challenge_id_fk FOREIGN KEY (challenge_id) REFERENCES hydra_oauth2_flow(consent_challenge_id) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_device_code ADD CONSTRAINT hydra_oauth2_device_code_client_id_fk FOREIGN KEY (client_id, nid) REFERENCES hydra_client(id, nid) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_device_code ADD CONSTRAINT hydra_oauth2_device_code_nid_fk_idx FOREIGN KEY (nid) REFERENCES networks(id) ON UPDATE RESTRICT ON DELETE CASCADE;
+
+CREATE TABLE IF NOT EXISTS hydra_oauth2_user_code 
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(40)  NOT NULL DEFAULT '',
+    requested_at       TIMESTAMP    NOT NULL DEFAULT NOW(),
+    client_id          VARCHAR(255) NOT NULL DEFAULT '',
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             BOOL         NOT NULL DEFAULT true,
+    requested_audience TEXT         NOT NULL,
+    granted_audience   TEXT         NOT NULL,
+    challenge_id       VARCHAR(40)  NULL,
+    nid                CHAR(36)     NOT NULL
+);
+CREATE INDEX hydra_oauth2_user_code_nid_fk_idx ON hydra_oauth2_user_code (nid);
+CREATE INDEX hydra_oauth2_user_code_request_id_idx ON hydra_oauth2_user_code (request_id, nid);
+CREATE INDEX hydra_oauth2_user_code_client_id_idx ON hydra_oauth2_user_code (client_id, nid);
+CREATE INDEX hydra_oauth2_user_code_challenge_id_idx ON hydra_oauth2_user_code (challenge_id);
+ALTER TABLE hydra_oauth2_user_code ADD CONSTRAINT hydra_oauth2_user_code_challenge_id_fk FOREIGN KEY (challenge_id) REFERENCES hydra_oauth2_flow(consent_challenge_id) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_user_code ADD CONSTRAINT hydra_oauth2_user_code_client_id_fk FOREIGN KEY (client_id, nid) REFERENCES hydra_client(id, nid) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_user_code ADD CONSTRAINT hydra_oauth2_user_code_nid_fk_idx FOREIGN KEY (nid) REFERENCES networks(id) ON UPDATE RESTRICT ON DELETE CASCADE;
diff --git a/persistence/sql/migrations/20220823111500000000_support_device_grants.postgres.up.sql b/persistence/sql/migrations/20220823111500000000_support_device_grants.postgres.up.sql
new file mode 100644
index 0000000000..8117f70554
--- /dev/null
+++ b/persistence/sql/migrations/20220823111500000000_support_device_grants.postgres.up.sql
@@ -0,0 +1,47 @@
+CREATE TABLE IF NOT EXISTS hydra_oauth2_device_code 
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(40)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT NOW(),
+    client_id          VARCHAR(255) NOT NULL,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             BOOL         NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL DEFAULT '',
+    granted_audience   TEXT         NULL DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL,
+    nid                UUID         NULL
+);
+CREATE INDEX hydra_oauth2_device_code_request_id_idx ON hydra_oauth2_device_code (request_id, nid);
+CREATE INDEX hydra_oauth2_device_code_client_id_idx ON hydra_oauth2_device_code (client_id, nid);
+CREATE INDEX hydra_oauth2_device_code_challenge_id_idx ON hydra_oauth2_device_code (challenge_id, nid);
+ALTER TABLE hydra_oauth2_device_code ADD CONSTRAINT hydra_oauth2_device_code_challenge_id_fk FOREIGN KEY (challenge_id) REFERENCES hydra_oauth2_flow(consent_challenge_id) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_device_code ADD CONSTRAINT hydra_oauth2_device_code_client_id_fk FOREIGN KEY (client_id, nid) REFERENCES hydra_client(id, nid) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_device_code ADD CONSTRAINT hydra_oauth2_device_code_nid_fk_idx FOREIGN KEY (nid) REFERENCES networks(id) ON UPDATE RESTRICT ON DELETE CASCADE;
+
+CREATE TABLE IF NOT EXISTS hydra_oauth2_user_code 
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(255) NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT NOW(),
+    client_id          VARCHAR(255) NOT NULL,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             BOOL         NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL DEFAULT '',
+    granted_audience   TEXT         NULL DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL,
+    nid                UUID         NULL
+);
+CREATE INDEX hydra_oauth2_user_code_request_id_idx ON hydra_oauth2_user_code (request_id, nid);
+CREATE INDEX hydra_oauth2_user_code_client_id_idx ON hydra_oauth2_user_code (client_id, nid);
+CREATE INDEX hydra_oauth2_user_code_challenge_id_idx ON hydra_oauth2_user_code (challenge_id, nid);
+ALTER TABLE hydra_oauth2_user_code ADD CONSTRAINT hydra_oauth2_user_code_challenge_id_fk FOREIGN KEY (challenge_id) REFERENCES hydra_oauth2_flow(consent_challenge_id) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_user_code ADD CONSTRAINT hydra_oauth2_user_code_client_id_fk FOREIGN KEY (client_id, nid) REFERENCES hydra_client(id, nid) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_user_code ADD CONSTRAINT hydra_oauth2_user_code_nid_fk_idx FOREIGN KEY (nid) REFERENCES networks(id) ON UPDATE RESTRICT ON DELETE CASCADE;
diff --git a/persistence/sql/migrations/20220823111500000000_support_device_grants.up.sql b/persistence/sql/migrations/20220823111500000000_support_device_grants.up.sql
new file mode 100644
index 0000000000..60f71119cc
--- /dev/null
+++ b/persistence/sql/migrations/20220823111500000000_support_device_grants.up.sql
@@ -0,0 +1,41 @@
+CREATE TABLE IF NOT EXISTS hydra_oauth2_device_code 
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(255)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    client_id          VARCHAR(255) NOT NULL,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             BOOL         NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL DEFAULT '',
+    granted_audience   TEXT         NULL DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL REFERENCES hydra_oauth2_flow (consent_challenge_id) ON DELETE CASCADE,
+    nid                VARCHAR(36)  NULL REFERENCES networks(id) ON DELETE CASCADE ON UPDATE RESTRICT
+);
+CREATE INDEX hydra_oauth2_device_code_request_id_idx ON hydra_oauth2_device_code (request_id, nid);
+CREATE INDEX hydra_oauth2_device_code_client_id_idx ON hydra_oauth2_device_code (client_id, nid);
+CREATE INDEX hydra_oauth2_device_code_challenge_id_idx ON hydra_oauth2_device_code (challenge_id, nid);
+
+CREATE TABLE IF NOT EXISTS hydra_oauth2_user_code 
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(40)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    client_id          VARCHAR(255) NOT NULL,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             BOOL         NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL DEFAULT '',
+    granted_audience   TEXT         NULL DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL REFERENCES hydra_oauth2_flow (consent_challenge_id) ON DELETE CASCADE,
+    nid                VARCHAR(36)  NULL REFERENCES networks(id) ON DELETE CASCADE ON UPDATE RESTRICT
+);
+CREATE INDEX hydra_oauth2_user_code_request_id_idx ON hydra_oauth2_user_code (request_id, nid);
+CREATE INDEX hydra_oauth2_user_code_client_id_idx ON hydra_oauth2_user_code (client_id, nid);
+CREATE INDEX hydra_oauth2_user_code_challenge_id_idx ON hydra_oauth2_user_code (challenge_id, nid);
\ No newline at end of file
diff --git a/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.cockroach.up.sql b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.cockroach.up.sql
new file mode 100644
index 0000000000..d7d5ecba5b
--- /dev/null
+++ b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.cockroach.up.sql
@@ -0,0 +1,19 @@
+CREATE TABLE hydra_oauth2_device_grant_request
+(
+    challenge             VARCHAR(40)  NOT NULL PRIMARY KEY,
+    requested_scope       TEXT         NOT NULL,
+    verifier              VARCHAR(40)  NOT NULL UNIQUE,
+    client_id             VARCHAR(255) NULL,
+    request_url           TEXT         NOT NULL,
+    requested_audience    VARCHAR(255) NULL     DEFAULT '',
+    csrf                  VARCHAR(40)  NOT NULL,
+    device_code_signature VARCHAR(255) NULL,
+    accepted              BOOL         NOT NULL DEFAULT true,
+    accepted_at           TIMESTAMP    NULL,
+    nid                   UUID         NULL
+);
+CREATE INDEX hydra_oauth2_device_grant_request_client_id_idx ON hydra_oauth2_device_grant_request (client_id, nid);
+CREATE INDEX hydra_oauth2_device_grant_request_verifier_idx ON hydra_oauth2_device_grant_request (verifier, nid);
+CREATE INDEX hydra_oauth2_device_grant_request_challenge_idx ON hydra_oauth2_device_grant_request (challenge, nid);
+ALTER TABLE hydra_oauth2_device_grant_request ADD CONSTRAINT hydra_oauth2_device_grant_request_client_id_fk FOREIGN KEY (client_id, nid) REFERENCES hydra_client(id, nid) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_device_grant_request ADD CONSTRAINT hydra_oauth2_device_grant_request_nid_fk_idx FOREIGN KEY (nid) REFERENCES networks(id) ON UPDATE RESTRICT ON DELETE CASCADE;
diff --git a/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.down.sql b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.down.sql
new file mode 100644
index 0000000000..fdd3e7b01a
--- /dev/null
+++ b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.down.sql
@@ -0,0 +1,7 @@
+ALTER TABLE
+    hydra_oauth2_device_grant_request DROP FOREIGN KEY IF EXISTS hydra_oauth2_device_grant_request_client_id_fk;
+
+ALTER TABLE
+    hydra_oauth2_device_grant_request DROP FOREIGN KEY IF EXISTS hydra_oauth2_device_grant_request_nid_fk_idx;
+
+DROP TABLE IF EXISTS hydra_oauth2_device_grant_request;
\ No newline at end of file
diff --git a/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.mysql.up.sql b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.mysql.up.sql
new file mode 100644
index 0000000000..c137880c5b
--- /dev/null
+++ b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.mysql.up.sql
@@ -0,0 +1,19 @@
+CREATE TABLE hydra_oauth2_device_grant_request
+(
+    challenge             VARCHAR(40)  NOT NULL PRIMARY KEY,
+    requested_scope       TEXT         NOT NULL,
+    verifier              VARCHAR(40)  NOT NULL UNIQUE,
+    client_id             VARCHAR(255) NULL,
+    request_url           TEXT         NOT NULL,
+    requested_audience    VARCHAR(255) NULL     DEFAULT '',
+    csrf                  VARCHAR(40)  NOT NULL,
+    device_code_signature VARCHAR(255) NULL,
+    accepted              BOOL         NOT NULL DEFAULT true,
+    accepted_at           TIMESTAMP    NULL,
+    nid                   VARCHAR(36)  NULL
+);
+CREATE INDEX hydra_oauth2_device_grant_request_client_id_idx ON hydra_oauth2_device_grant_request (client_id, nid);
+CREATE INDEX hydra_oauth2_device_grant_request_verifier_idx ON hydra_oauth2_device_grant_request (verifier, nid);
+CREATE INDEX hydra_oauth2_device_grant_request_challenge_idx ON hydra_oauth2_device_grant_request (challenge, nid);
+ALTER TABLE hydra_oauth2_device_grant_request ADD CONSTRAINT hydra_oauth2_device_grant_request_client_id_fk FOREIGN KEY (client_id, nid) REFERENCES hydra_client(id, nid) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_device_grant_request ADD CONSTRAINT hydra_oauth2_device_grant_request_nid_fk_idx FOREIGN KEY (nid) REFERENCES networks(id) ON UPDATE RESTRICT ON DELETE CASCADE;
diff --git a/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.postgres.up.sql b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.postgres.up.sql
new file mode 100644
index 0000000000..d7d5ecba5b
--- /dev/null
+++ b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.postgres.up.sql
@@ -0,0 +1,19 @@
+CREATE TABLE hydra_oauth2_device_grant_request
+(
+    challenge             VARCHAR(40)  NOT NULL PRIMARY KEY,
+    requested_scope       TEXT         NOT NULL,
+    verifier              VARCHAR(40)  NOT NULL UNIQUE,
+    client_id             VARCHAR(255) NULL,
+    request_url           TEXT         NOT NULL,
+    requested_audience    VARCHAR(255) NULL     DEFAULT '',
+    csrf                  VARCHAR(40)  NOT NULL,
+    device_code_signature VARCHAR(255) NULL,
+    accepted              BOOL         NOT NULL DEFAULT true,
+    accepted_at           TIMESTAMP    NULL,
+    nid                   UUID         NULL
+);
+CREATE INDEX hydra_oauth2_device_grant_request_client_id_idx ON hydra_oauth2_device_grant_request (client_id, nid);
+CREATE INDEX hydra_oauth2_device_grant_request_verifier_idx ON hydra_oauth2_device_grant_request (verifier, nid);
+CREATE INDEX hydra_oauth2_device_grant_request_challenge_idx ON hydra_oauth2_device_grant_request (challenge, nid);
+ALTER TABLE hydra_oauth2_device_grant_request ADD CONSTRAINT hydra_oauth2_device_grant_request_client_id_fk FOREIGN KEY (client_id, nid) REFERENCES hydra_client(id, nid) ON DELETE CASCADE;
+ALTER TABLE hydra_oauth2_device_grant_request ADD CONSTRAINT hydra_oauth2_device_grant_request_nid_fk_idx FOREIGN KEY (nid) REFERENCES networks(id) ON UPDATE RESTRICT ON DELETE CASCADE;
diff --git a/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.up.sql b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.up.sql
new file mode 100644
index 0000000000..e729311952
--- /dev/null
+++ b/persistence/sql/migrations/20220824111500000000_support_device_grant_consent.up.sql
@@ -0,0 +1,17 @@
+CREATE TABLE hydra_oauth2_device_grant_request
+(
+    challenge             VARCHAR(40)  NOT NULL PRIMARY KEY,
+    requested_scope       TEXT         NOT NULL,
+    verifier              VARCHAR(40)  NOT NULL UNIQUE,
+    client_id             VARCHAR(255) NULL,
+    request_url           TEXT         NOT NULL,
+    requested_audience    VARCHAR(255) NULL     DEFAULT '',
+    csrf                  VARCHAR(40)  NOT NULL,
+    device_code_signature VARCHAR(255) NULL,
+    accepted              BOOL         NOT NULL DEFAULT true,
+    accepted_at           TIMESTAMP    NULL,
+    nid                   VARCHAR(36)  NULL REFERENCES networks(id) ON DELETE CASCADE ON UPDATE RESTRICT
+);
+CREATE INDEX hydra_oauth2_device_grant_request_client_id_idx ON hydra_oauth2_device_grant_request (client_id);
+CREATE INDEX hydra_oauth2_device_grant_request_verifier_idx ON hydra_oauth2_device_grant_request (verifier);
+CREATE INDEX hydra_oauth2_device_grant_request_challenge_idx ON hydra_oauth2_device_grant_request (challenge);
\ No newline at end of file
diff --git a/persistence/sql/persister_consent.go b/persistence/sql/persister_consent.go
index 8f1fca3d49..382a8c3891 100644
--- a/persistence/sql/persister_consent.go
+++ b/persistence/sql/persister_consent.go
@@ -217,6 +217,60 @@ func (p *Persister) GetConsentRequest(ctx context.Context, challenge string) (*c
 	return f.GetConsentRequest(), nil
 }
 
+func (p *Persister) CreateDeviceGrantRequest(ctx context.Context, req *consent.DeviceGrantRequest) error {
+	return errorsx.WithStack(p.CreateWithNetwork(ctx, req))
+}
+
+func (p *Persister) GetDeviceGrantRequestByVerifier(ctx context.Context, verifier string) (*consent.DeviceGrantRequest, error) {
+	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.GetDeviceGrantRequestByVerifier")
+	defer span.End()
+
+	var dgr consent.DeviceGrantRequest
+	return &dgr, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		if err := c.Where("verifier = ?", verifier).First(&dgr); err != nil {
+			if errors.Is(err, sql.ErrNoRows) {
+				return errorsx.WithStack(x.ErrNotFound)
+			}
+			return sqlcon.HandleError(err)
+		}
+
+		return nil
+	})
+}
+
+func (p *Persister) AcceptDeviceGrantRequest(ctx context.Context, challenge string, device_code_signature string, client_id string, requested_scopes fosite.Arguments, requested_aud fosite.Arguments) (*consent.DeviceGrantRequest, error) {
+	var dgr consent.DeviceGrantRequest
+	return &dgr, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		if err := p.QueryWithNetwork(ctx).Where("challenge = ?", challenge).First(&dgr); err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		dgr.Accepted = true
+		dgr.AcceptedAt = sqlxx.NullTime(time.Now())
+		dgr.DeviceCodeSignature = sqlxx.NullString(device_code_signature)
+		dgr.ClientID = sqlxx.NullString(client_id)
+		dgr.RequestedScope = sqlxx.StringSlicePipeDelimiter(requested_scopes)
+		dgr.RequestedAudience = sqlxx.StringSlicePipeDelimiter(requested_aud)
+
+		count, err := p.UpdateWithNetwork(ctx, &dgr)
+		if count != 1 {
+			return errorsx.WithStack(x.ErrNotFound)
+		}
+		return err
+	})
+}
+
+func (p *Persister) VerifyAndInvalidateDeviceGrantRequest(ctx context.Context, verifier string) (*consent.DeviceGrantRequest, error) {
+	var d consent.DeviceGrantRequest
+	return &d, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		if err := p.QueryWithNetwork(ctx).Where("verifier = ?", verifier).First(&d); err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		return sqlcon.HandleError(p.QueryWithNetwork(ctx).Where("verifier = ?", verifier).Delete(&d))
+	})
+}
+
 func (p *Persister) CreateLoginRequest(ctx context.Context, req *consent.LoginRequest) error {
 	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.CreateLoginRequest")
 	defer span.End()
diff --git a/persistence/sql/persister_oauth2.go b/persistence/sql/persister_oauth2.go
index e2ae388751..ffae7458bf 100644
--- a/persistence/sql/persister_oauth2.go
+++ b/persistence/sql/persister_oauth2.go
@@ -55,11 +55,13 @@ type (
 )
 
 const (
-	sqlTableOpenID  tableName = "oidc"
-	sqlTableAccess  tableName = "access"
-	sqlTableRefresh tableName = "refresh"
-	sqlTableCode    tableName = "code"
-	sqlTablePKCE    tableName = "pkce"
+	sqlTableOpenID     tableName = "oidc"
+	sqlTableAccess     tableName = "access"
+	sqlTableRefresh    tableName = "refresh"
+	sqlTableCode       tableName = "code"
+	sqlTablePKCE       tableName = "pkce"
+	sqlTableDeviceCode tableName = "device_code"
+	sqlTableUserCode   tableName = "user_code"
 )
 
 func (r OAuth2RequestSQL) TableName() string {
@@ -244,6 +246,28 @@ func (p *Persister) createSession(ctx context.Context, signature string, request
 	return nil
 }
 
+func (p *Persister) updateSessionBySignature(ctx context.Context, signature string, requester fosite.Requester, table tableName) error {
+	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.updateSession")
+	defer span.End()
+
+	req, err := p.sqlSchemaFromRequest(ctx, signature, requester, table)
+	if err != nil {
+		return err
+	}
+
+	if count, err := p.UpdateWithNetwork(ctx, req); count != 1 {
+		return errorsx.WithStack(fosite.ErrNotFound)
+	} else if err := sqlcon.HandleError(err); err != nil {
+		if errors.Is(err, sqlcon.ErrConcurrentUpdate) {
+			return errors.Wrap(fosite.ErrSerializationFailure, err.Error())
+		} else if strings.Contains(err.Error(), "Error 1213") { // InnoDB Deadlock?
+			return errors.Wrap(fosite.ErrSerializationFailure, err.Error())
+		}
+		return err
+	}
+	return nil
+}
+
 func (p *Persister) findSessionBySignature(ctx context.Context, rawSignature string, session fosite.Session, table tableName) (fosite.Requester, error) {
 	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.findSessionBySignature")
 	defer span.End()
@@ -267,11 +291,26 @@ func (p *Persister) findSessionBySignature(ctx context.Context, rawSignature str
 			fr, err = r.toRequest(ctx, session, p)
 			if err != nil {
 				return err
-			} else if table == sqlTableCode {
+			}
+			switch table {
+			case sqlTableCode:
 				return errorsx.WithStack(fosite.ErrInvalidatedAuthorizeCode)
+			case sqlTableDeviceCode:
+				return errorsx.WithStack(fosite.ErrInvalidatedDeviceCode)
+			case sqlTableUserCode:
+				return errorsx.WithStack(fosite.ErrInvalidatedUserCode)
 			}
 
 			return errorsx.WithStack(fosite.ErrInactiveToken)
+		} else if !r.ConsentChallenge.Valid {
+			fr, err = r.toRequest(ctx, session, p)
+			if err != nil {
+				return err
+			}
+
+			if table == sqlTableDeviceCode {
+				return errorsx.WithStack(fosite.ErrAuthorizationPending)
+			}
 		}
 
 		fr, err = r.toRequest(ctx, session, p)
@@ -482,3 +521,70 @@ func (p *Persister) DeleteAccessTokens(ctx context.Context, clientID string) err
 		p.QueryWithNetwork(ctx).Where("client_id=?", clientID).Delete(&OAuth2RequestSQL{Table: sqlTableAccess}),
 	)
 }
+
+func (p *Persister) CreateDeviceCodeSession(ctx context.Context, signature string, requester fosite.Requester) error {
+	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.CreateDeviceCodeSession")
+	defer span.End()
+
+	return p.createSession(ctx, signature, requester, sqlTableDeviceCode)
+}
+
+func (p *Persister) UpdateDeviceCodeSession(ctx context.Context, signature string, requester fosite.Requester) error {
+	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.UpdateDeviceCodeSession")
+	defer span.End()
+
+	return p.updateSessionBySignature(ctx, signature, requester, sqlTableDeviceCode)
+}
+
+func (p *Persister) GetDeviceCodeSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) {
+	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.GetDeviceCodeSession")
+	defer span.End()
+
+	return p.findSessionBySignature(ctx, signature, session, sqlTableDeviceCode)
+}
+
+func (p *Persister) InvalidateDeviceCodeSession(ctx context.Context, signature string) error {
+	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.InvalidateDeviceCodeSession")
+	defer span.End()
+
+	/* #nosec G201 table is static */
+	return sqlcon.HandleError(
+		p.Connection(ctx).
+			RawQuery(
+				fmt.Sprintf("UPDATE %s SET active=false WHERE signature=? AND nid = ?", OAuth2RequestSQL{Table: sqlTableDeviceCode}.TableName()),
+				signature,
+				p.NetworkID(ctx),
+			).
+			Exec(),
+	)
+}
+
+func (p *Persister) CreateUserCodeSession(ctx context.Context, signature string, requester fosite.Requester) error {
+	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.CreateUserCodeSession")
+	defer span.End()
+
+	return p.createSession(ctx, signature, requester, sqlTableUserCode)
+}
+
+func (p *Persister) GetUserCodeSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) {
+	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.GetUserCodeSession")
+	defer span.End()
+
+	return p.findSessionBySignature(ctx, signature, session, sqlTableUserCode)
+}
+
+func (p *Persister) InvalidateUserCodeSession(ctx context.Context, signature string) error {
+	ctx, span := p.r.Tracer(ctx).Tracer().Start(ctx, "persistence.sql.InvalidateUserCodeSession")
+	defer span.End()
+
+	/* #nosec G201 table is static */
+	return sqlcon.HandleError(
+		p.Connection(ctx).
+			RawQuery(
+				fmt.Sprintf("UPDATE %s SET active=false WHERE signature=? AND nid = ?", OAuth2RequestSQL{Table: sqlTableUserCode}.TableName()),
+				signature,
+				p.NetworkID(ctx),
+			).
+			Exec(),
+	)
+}
diff --git a/spec/api.json b/spec/api.json
index d155f46770..6d9292087c 100644
--- a/spec/api.json
+++ b/spec/api.json
@@ -88,6 +88,13 @@
         "title": "StringSliceJSONFormat represents []string{} which is encoded to/from JSON for SQL storage.",
         "type": "array"
       },
+      "StringSlicePipeDelimiter": {
+        "items": {
+          "type": "string"
+        },
+        "title": "StringSlicePipeDelimiter de/encodes the string slice to/from a SQL string.",
+        "type": "array"
+      },
       "Time": {
         "format": "date-time",
         "type": "string"
@@ -198,6 +205,77 @@
         ],
         "type": "object"
       },
+      "deviceAuthorization": {
+        "description": "# Ory's OAuth 2.0 Device Authorization API",
+        "properties": {
+          "device_code": {
+            "description": "The device verification code.",
+            "example": "ory_dc_smldfksmdfkl.mslkmlkmlk",
+            "type": "string"
+          },
+          "expires_in": {
+            "description": "The lifetime in seconds of the \"device_code\" and \"user_code\".",
+            "example": 16830,
+            "format": "int64",
+            "type": "integer"
+          },
+          "interval": {
+            "description": "The minimum amount of time in seconds that the client\nSHOULD wait between polling requests to the token endpoint.  If no\nvalue is provided, clients MUST use 5 as the default.",
+            "example": 5,
+            "format": "int64",
+            "type": "integer"
+          },
+          "user_code": {
+            "description": "The end-user verification code.",
+            "example": "AAAAAA",
+            "type": "string"
+          },
+          "verification_uri": {
+            "description": "The end-user verification URI on the authorization\nserver.  The URI should be short and easy to remember as end users\nwill be asked to manually type it into their user agent.",
+            "example": "https://auth.ory.sh/tv",
+            "type": "string"
+          },
+          "verification_uri_complete": {
+            "description": "A verification URI that includes the \"user_code\" (or\nother information with the same function as the \"user_code\"),\nwhich is designed for non-textual transmission.",
+            "example": "https://auth.ory.sh/tv?user_code=AAAAAA",
+            "type": "string"
+          }
+        },
+        "title": "OAuth2 Device Flow",
+        "type": "object"
+      },
+      "deviceGrantRequest": {
+        "properties": {
+          "challenge": {
+            "description": "ID is the identifier (\"device challenge\") of the device grant request. It is used to\nidentify the session.",
+            "type": "string"
+          },
+          "client": {
+            "$ref": "#/components/schemas/oAuth2Client"
+          },
+          "handled_at": {
+            "$ref": "#/components/schemas/nullTime"
+          },
+          "request_url": {
+            "description": "RequestURL is the original Device Grant URL requested.",
+            "type": "string"
+          },
+          "requested_access_token_audience": {
+            "$ref": "#/components/schemas/StringSlicePipeDelimiter"
+          },
+          "requested_scope": {
+            "$ref": "#/components/schemas/StringSlicePipeDelimiter"
+          }
+        },
+        "required": [
+          "challenge",
+          "requested_scope",
+          "requested_access_token_audience",
+          "client"
+        ],
+        "title": "Contains information on an ongoing device grant request.",
+        "type": "object"
+      },
       "errorOAuth2": {
         "description": "Error",
         "properties": {
@@ -1039,6 +1117,10 @@
             },
             "type": "array"
           },
+          "device_authorization_endpoint": {
+            "description": "URL of the authorization server's device authorization endpoint",
+            "type": "string"
+          },
           "end_session_endpoint": {
             "description": "OpenID Connect End-Session Endpoint\n\nURL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP.",
             "type": "string"
@@ -1510,6 +1592,15 @@
         },
         "type": "object"
       },
+      "verifyUserCodeRequest": {
+        "description": "Contains information on an device verification",
+        "properties": {
+          "user_code": {
+            "type": "string"
+          }
+        },
+        "type": "object"
+	  },
       "unexpectedError": {
         "type": "string"
       },
@@ -2439,6 +2530,58 @@
         ]
       }
     },
+    "/admin/oauth2/auth/requests/device/verify": {
+      "put": {
+        "description": "Verifies a device grant request",
+        "operationId": "verifyUserCodeRequest",
+        "parameters": [
+          {
+            "in": "query",
+            "name": "device_challenge",
+            "required": true,
+            "schema": {
+              "type": "string"
+            }
+          }
+        ],
+        "requestBody": {
+          "content": {
+            "application/json": {
+              "schema": {
+                "$ref": "#/components/schemas/verifyUserCodeRequest"
+              }
+            }
+          },
+          "x-originalParamName": "Body"
+        },
+        "responses": {
+          "200": {
+            "content": {
+              "application/json": {
+                "schema": {
+                  "$ref": "#/components/schemas/oAuth2RedirectTo"
+                }
+              }
+            },
+            "description": "oAuth2RedirectTo"
+          },
+          "default": {
+            "content": {
+              "application/json": {
+                "schema": {
+                  "$ref": "#/components/schemas/errorOAuth2"
+                }
+              }
+            },
+            "description": "errorOAuth2"
+          }
+        },
+        "summary": "Verifies a device grant request",
+        "tags": [
+          "oAuth2"
+        ]
+      }
+    },
     "/admin/oauth2/auth/requests/login": {
       "get": {
         "description": "When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider\nto authenticate the subject and then tell the Ory OAuth2 Service about it.\n\nPer default, the login provider is Ory itself. You may use a different login provider which needs to be a web-app\nyou write and host, and it must be able to authenticate (\"show the subject a login screen\")\na subject (in OAuth2 the proper name for subject is \"resource owner\").\n\nThe authentication challenge is appended to the login provider URL to which the subject's user-agent (browser) is redirected to. The login\nprovider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.",
@@ -3268,6 +3411,38 @@
         ]
       }
     },
+    "/oauth2/device/auth": {
+      "get": {
+        "description": "This endpoint is not documented here because you should never use your own implementation to perform OAuth2 flows.\nOAuth2 is a very popular protocol and a library for your programming language will exists.\n\nTo learn more about this flow please refer to the specification: https://tools.ietf.org/html/rfc8628",
+        "operationId": "performOAuth2DeviceFlow",
+        "responses": {
+          "200": {
+            "content": {
+              "application/json": {
+                "schema": {
+                  "$ref": "#/components/schemas/deviceAuthorization"
+                }
+              }
+            },
+            "description": "deviceAuthorization"
+          },
+          "default": {
+            "content": {
+              "application/json": {
+                "schema": {
+                  "$ref": "#/components/schemas/errorOAuth2"
+                }
+              }
+            },
+            "description": "errorOAuth2"
+          }
+        },
+        "summary": "The OAuth 2.0 Device Authorize Endpoint",
+        "tags": [
+          "v0alpha2"
+        ]
+      }
+    },
     "/oauth2/register": {
       "post": {
         "description": "This endpoint behaves like the administrative counterpart (`createOAuth2Client`) but is capable of facing the\npublic internet directly and can be used in self-service. It implements the OpenID Connect\nDynamic Client Registration Protocol. This feature needs to be enabled in the configuration. This endpoint\nis disabled by default. It can be enabled by an administrator.\n\nPlease note that using this endpoint you are not able to choose the `client_secret` nor the `client_id` as those\nvalues will be server generated when specifying `token_endpoint_auth_method` as `client_secret_basic` or\n`client_secret_post`.\n\nThe `client_secret` will be returned in the response and you will not be able to retrieve it later on.\nWrite the secret down and keep it somewhere safe.",
diff --git a/spec/config.json b/spec/config.json
index 3d63b69a2c..4eb5287b13 100644
--- a/spec/config.json
+++ b/spec/config.json
@@ -433,6 +433,11 @@
                   "title": "CSRF Cookie Name",
                   "default": "ory_hydra_consent_csrf"
                 },
+                "consent_device_verify": {
+                  "type": "string",
+                  "title": "CSRF Cookie Name",
+                  "default": "ory_hydra_device_verify_csrf"
+                },
                 "session": {
                   "type": "string",
                   "title": "Session Cookie Name",
@@ -563,6 +568,14 @@
                 "https://my-service.com/oauth2/auth"
               ]
             },
+            "device_authorization_url": {
+              "type": "string",
+              "description": "Overwrites the OAuth2 Device Auth URL",
+              "format": "uri-reference",
+              "examples": [
+                "https://my-service.com/oauth2/device/auth"
+              ]
+            },
             "client_registration_url": {
               "description": "Sets the OpenID Connect Dynamic Client Registration Endpoint",
               "type": "string",
@@ -743,6 +756,15 @@
             "/ui/logout"
           ]
         },
+        "device": {
+          "type": "string",
+          "description": "Sets the device auth endpoint. Defaults to an internal fallback URL showing an error.",
+          "format": "uri-reference",
+          "examples": [
+            "https://my-logout.app/device",
+            "/ui/device"
+          ]
+        },
         "error": {
           "type": "string",
           "description": "Sets the error endpoint. The error ui will be shown when an OAuth2 error occurs that which can not be sent back to the client. Defaults to an internal fallback URL showing an error.",
@@ -760,6 +782,15 @@
             "https://my-example.app/logout-successful",
             "/ui"
           ]
+        },
+        "post_device_done": {
+          "type": "string",
+          "description": "When a user agent requests to device auth flow, it will be redirected to this url after a sucessfull login per default.",
+          "format": "uri-reference",
+          "examples": [
+            "https://my-example.app/device-successful",
+            "/ui"
+          ]
         }
       }
     },
@@ -839,6 +870,15 @@
               "$ref": "#/definitions/duration"
             }
           ]
+        },
+        "device_user_code": {
+          "description": "Configures how long device & user codes are valid.",
+          "default": "10m",
+          "allOf": [
+            {
+              "$ref": "#/definitions/duration"
+            }
+          ]
         }
       }
     },
@@ -988,6 +1028,22 @@
           "format": "uri",
           "examples": ["https://my-example.app/token-refresh-hook"]
         },
+        "device_authorization": {
+          "type": "object",
+          "additionalProperties": false,
+          "properties": {
+            "token_polling_interval": {
+              "allOf": [
+                {
+                  "$ref": "#/definitions/duration"
+                }
+              ],
+              "default": "5s",
+              "description": "configure how often a non-interactive device should poll the device token endpoint",
+              "examples": ["5s", "15s", "1m"]
+            }
+          }
+        },
         "token_hook": {
           "type": "string",
           "description": "Sets the token hook endpoint for all grant types. If set it will be called while providing token to customize claims.",
diff --git a/spec/swagger.json b/spec/swagger.json
index a492e63c9b..1e0456d49e 100755
--- a/spec/swagger.json
+++ b/spec/swagger.json
@@ -891,6 +891,55 @@
         }
       }
     },
+    "/admin/oauth2/auth/requests/device/verify": {
+      "put": {
+        "description": "Verifies a device grant request",
+        "consumes": [
+          "application/json"
+        ],
+        "produces": [
+          "application/json"
+        ],
+        "schemes": [
+          "http",
+          "https"
+        ],
+        "tags": [
+          "oAuth2"
+        ],
+        "summary": "Verifies a device grant request",
+        "operationId": "verifyUserCodeRequest",
+        "parameters": [
+          {
+            "type": "string",
+            "name": "device_challenge",
+            "in": "query",
+            "required": true
+          },
+          {
+            "name": "Body",
+            "in": "body",
+            "schema": {
+              "$ref": "#/definitions/verifyUserCodeRequest"
+            }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "oAuth2RedirectTo",
+            "schema": {
+              "$ref": "#/definitions/oAuth2RedirectTo"
+            }
+          },
+          "default": {
+            "description": "errorOAuth2",
+            "schema": {
+              "$ref": "#/definitions/errorOAuth2"
+            }
+          }
+        }
+      }
+    },
     "/admin/oauth2/auth/requests/login": {
       "get": {
         "description": "When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider\nto authenticate the subject and then tell the Ory OAuth2 Service about it.\n\nPer default, the login provider is Ory itself. You may use a different login provider which needs to be a web-app\nyou write and host, and it must be able to authenticate (\"show the subject a login screen\")\na subject (in OAuth2 the proper name for subject is \"resource owner\").\n\nThe authentication challenge is appended to the login provider URL to which the subject's user-agent (browser) is redirected to. The login\nprovider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.",
@@ -1667,6 +1716,37 @@
         }
       }
     },
+    "/oauth2/device/auth": {
+      "get": {
+        "description": "This endpoint is not documented here because you should never use your own implementation to perform OAuth2 flows.\nOAuth2 is a very popular protocol and a library for your programming language will exists.\n\nTo learn more about this flow please refer to the specification: https://tools.ietf.org/html/rfc8628",
+        "consumes": [
+          "application/x-www-form-urlencoded"
+        ],
+        "schemes": [
+          "http",
+          "https"
+        ],
+        "tags": [
+          "v0alpha2"
+        ],
+        "summary": "The OAuth 2.0 Device Authorize Endpoint",
+        "operationId": "performOAuth2DeviceFlow",
+        "responses": {
+          "200": {
+            "description": "deviceAuthorization",
+            "schema": {
+              "$ref": "#/definitions/deviceAuthorization"
+            }
+          },
+          "default": {
+            "description": "errorOAuth2",
+            "schema": {
+              "$ref": "#/definitions/errorOAuth2"
+            }
+          }
+        }
+      }
+    },
     "/oauth2/register": {
       "post": {
         "description": "This endpoint behaves like the administrative counterpart (`createOAuth2Client`) but is capable of facing the\npublic internet directly and can be used in self-service. It implements the OpenID Connect\nDynamic Client Registration Protocol. This feature needs to be enabled in the configuration. This endpoint\nis disabled by default. It can be enabled by an administrator.\n\nPlease note that using this endpoint you are not able to choose the `client_secret` nor the `client_id` as those\nvalues will be server generated when specifying `token_endpoint_auth_method` as `client_secret_basic` or\n`client_secret_post`.\n\nThe `client_secret` will be returned in the response and you will not be able to retrieve it later on.\nWrite the secret down and keep it somewhere safe.",
@@ -2071,6 +2151,13 @@
         "type": "string"
       }
     },
+    "StringSlicePipeDelimiter": {
+      "type": "array",
+      "title": "StringSlicePipeDelimiter de/encodes the string slice to/from a SQL string.",
+      "items": {
+        "type": "string"
+      }
+    },
     "acceptOAuth2ConsentRequest": {
       "type": "object",
       "title": "The request payload used to accept a consent request.",
@@ -2177,6 +2264,77 @@
         }
       }
     },
+    "deviceAuthorization": {
+      "description": "# Ory's OAuth 2.0 Device Authorization API",
+      "type": "object",
+      "title": "OAuth2 Device Flow",
+      "properties": {
+        "device_code": {
+          "description": "The device verification code.",
+          "type": "string",
+          "example": "ory_dc_smldfksmdfkl.mslkmlkmlk"
+        },
+        "expires_in": {
+          "description": "The lifetime in seconds of the \"device_code\" and \"user_code\".",
+          "type": "integer",
+          "format": "int64",
+          "example": 16830
+        },
+        "interval": {
+          "description": "The minimum amount of time in seconds that the client\nSHOULD wait between polling requests to the token endpoint.  If no\nvalue is provided, clients MUST use 5 as the default.",
+          "type": "integer",
+          "format": "int64",
+          "example": 5
+        },
+        "user_code": {
+          "description": "The end-user verification code.",
+          "type": "string",
+          "example": "AAAAAA"
+        },
+        "verification_uri": {
+          "description": "The end-user verification URI on the authorization\nserver.  The URI should be short and easy to remember as end users\nwill be asked to manually type it into their user agent.",
+          "type": "string",
+          "example": "https://auth.ory.sh/tv"
+        },
+        "verification_uri_complete": {
+          "description": "A verification URI that includes the \"user_code\" (or\nother information with the same function as the \"user_code\"),\nwhich is designed for non-textual transmission.",
+          "type": "string",
+          "example": "https://auth.ory.sh/tv?user_code=AAAAAA"
+        }
+      }
+    },
+    "deviceGrantRequest": {
+      "type": "object",
+      "title": "Contains information on an ongoing device grant request.",
+      "required": [
+        "challenge",
+        "requested_scope",
+        "requested_access_token_audience",
+        "client"
+      ],
+      "properties": {
+        "challenge": {
+          "description": "ID is the identifier (\"device challenge\") of the device grant request. It is used to\nidentify the session.",
+          "type": "string"
+        },
+        "client": {
+          "$ref": "#/definitions/oAuth2Client"
+        },
+        "handled_at": {
+          "$ref": "#/definitions/nullTime"
+        },
+        "request_url": {
+          "description": "RequestURL is the original Device Grant URL requested.",
+          "type": "string"
+        },
+        "requested_access_token_audience": {
+          "$ref": "#/definitions/StringSlicePipeDelimiter"
+        },
+        "requested_scope": {
+          "$ref": "#/definitions/StringSlicePipeDelimiter"
+        }
+      }
+    },
     "errorOAuth2": {
       "description": "Error",
       "type": "object",
@@ -2999,6 +3157,10 @@
             "type": "string"
           }
         },
+        "device_authorization_endpoint": {
+          "description": "URL of the authorization server's device authorization endpoint",
+          "type": "string"
+        },
         "end_session_endpoint": {
           "description": "OpenID Connect End-Session Endpoint\n\nURL at the OP to which an RP can perform a redirect to request that the End-User be logged out at the OP.",
           "type": "string"
@@ -3457,6 +3619,15 @@
         }
       }
     },
+    "verifyUserCodeRequest": {
+      "description": "Contains information on an device verification",
+      "type": "object",
+      "properties": {
+        "user_code": {
+          "type": "string"
+        }
+      }
+    },
     "unexpectedError": {
       "type": "string"
     },
diff --git a/x/clean_sql.go b/x/clean_sql.go
index 59628fb3f9..2a6e514725 100644
--- a/x/clean_sql.go
+++ b/x/clean_sql.go
@@ -17,6 +17,9 @@ func DeleteHydraRows(t *testing.T, c *pop.Connection) {
 		"hydra_oauth2_code",
 		"hydra_oauth2_oidc",
 		"hydra_oauth2_pkce",
+		"hydra_oauth2_device_code",
+		"hydra_oauth2_user_code",
+		"hydra_oauth2_device_grant_request",
 		"hydra_oauth2_flow",
 		"hydra_oauth2_authentication_session",
 		"hydra_oauth2_obfuscated_authentication_session",
@@ -38,8 +41,11 @@ func CleanSQLPop(t *testing.T, c *pop.Connection) {
 		"hydra_oauth2_access",
 		"hydra_oauth2_refresh",
 		"hydra_oauth2_code",
+		"hydra_oauth2_device_code",
+		"hydra_oauth2_user_code",
 		"hydra_oauth2_oidc",
 		"hydra_oauth2_pkce",
+		"hydra_oauth2_device_grant_request",
 		"hydra_oauth2_flow",
 		"hydra_oauth2_authentication_session",
 		"hydra_oauth2_obfuscated_authentication_session",
diff --git a/x/fosite_storer.go b/x/fosite_storer.go
index 1afec03771..073a2b8d8f 100644
--- a/x/fosite_storer.go
+++ b/x/fosite_storer.go
@@ -12,14 +12,17 @@ import (
 	"github.com/ory/fosite/handler/openid"
 	"github.com/ory/fosite/handler/pkce"
 	"github.com/ory/fosite/handler/rfc7523"
+	"github.com/ory/fosite/handler/rfc8628"
 )
 
 type FositeStorer interface {
 	fosite.Storage
 	oauth2.CoreStorage
+	oauth2.AuthorizeCodeStorage
 	openid.OpenIDConnectRequestStorage
 	pkce.PKCERequestStorage
 	rfc7523.RFC7523KeyStorage
+	rfc8628.RFC8628CodeStorage
 
 	RevokeRefreshToken(ctx context.Context, requestID string) error
 
